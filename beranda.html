<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Risk & Reward Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <!-- jsPDF and html2canvas for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles based on user's provided CSS */
        body { font-family: 'Inter', sans-serif; background-color: #fcfcfc; color: #333; font-size: 0.8125rem; padding: 0; }
        .container-wrapper { background-color: #ffffff; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03); border-radius: 12px; border: 1px solid #eeeeee; padding: 1.5rem; margin-top: 6rem; /* Increased margin to accommodate larger header */ margin-left: auto; margin-right: auto; width: 100%; max-width: 1536px; }
        .header-global { position: fixed; top: 0; left: 0; right: 0; padding: 1rem 1.5rem; /* Adjusted padding for better mobile view */ background-color: rgba(255, 255, 255, 0.8); /* White and transparent */ backdrop-filter: blur(10px); border-bottom: 1px solid rgba(0, 0, 0, 0.1); display: flex; align-items: center; justify-content: space-between; z-index: 50; color: #333; /* Black text */ }
        .header-section { background-color: rgba(247, 247, 247, 0.8); border-bottom: 1px solid #e8e8e8; padding: 1.75rem 1.5rem; margin-left: -1.5rem; margin-right: -1.5rem; }
        .text-primary { color: #2a2a2a; }
        .input-label { color: #5a5a5a; font-weight: 500; font-size: 0.75rem; }
        .input-field, .select-field { border: 1px solid #e0e0e0; background-color: #ffffff; color: #333; border-radius: 6px; padding: 0.55rem 0.8rem; transition: border-color 0.2s, box-shadow 0.2s; font-size: 0.75rem; }
        .input-field:focus, .select-field:focus { border-color: #bbbbbb; outline: none; box-shadow: 0 0 0 2px rgba(187, 187, 187, 0.2); }
        .input-group-percent span { background-color: #f0f0f0; border: 1px solid #e0e0e0; border-left: none; border-radius: 0 6px 6px 0; color: #5a5a5a; padding: 0.55rem 0.8rem; font-size: 0.75rem; }
        .buy-button, .sell-button { border: 1px solid #e0e0e0; background-color: #f9f9f9; color: #5a5a5a; border-radius: 6px; transition: background-color 0.2s, color 0.2s, border-color 0.2s; font-size: 0.75rem; padding: 0.55rem 0.8rem; }
        .buy-button.active { background-color: #eafaea; color: #28a745; border-color: #c9ecc9; font-weight: 600; }
        .sell-button.active { background-color: #faeaea; color: #dc3545; border-color: #ecc9c9; font-weight: 600; }

        /* --- Perubahan untuk Tombol Aksi (Add, Calculate) --- */
        .action-button { background-color: #222222; color: #ffffff; border: 1px solid #111111; border-radius: 6px; font-weight: 600; padding: 0.6rem 1.1rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); font-size: 0.8125rem; }
        .action-button:hover { background-color: #3a3a3a; border-color: #222222; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15); }
        .action-button:active { box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
        /* --- End Perubahan Tombol Aksi --- */

        /* New style for the "Tambah Foto" button */
        .light-action-button { background-color: #e0e0e0; color: #222222; border: 1px solid #cccccc; border-radius: 6px; font-weight: 300; padding: 0.4rem 0.8rem; font-size: 0.75rem; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; box-shadow: 0 1px 3px (0, 0, 0, 0.08); }
        .light-action-button:hover { background-color: #d0d0d0; border-color: #bbbbbb; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .light-action-button:active { box-shadow: 0 0 2px rgba(0, 0, 0, 0.05); }

        /* New style for the "Hapus Data" button */
        .delete-data-button { background-color: transparent; color: #dc3545; border: none; font-weight: 300; font-size: 0.75rem; padding: 0.25rem 0.5rem; cursor: pointer; transition: color 0.2s; }
        .delete-data-button:hover { color: #c82333; }

        /* New style for the "Unggah Data" and "Unduh Excel" buttons */
        .upload-data-button { background-color: #e0e0e0; color: #222222; border: 1px solid #cccccc; border-radius: 6px; font-weight: 300; font-size: 0.75rem; padding: 0.25rem 0.5rem; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08); }
        .upload-data-button:hover { background-color: #d0d0d0; border-color: #bbbbbb; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .upload-data-button:active { box-shadow: 0 0 2px rgba(0, 0, 0, 0.05); }

        .delete-row-btn { color: #999; transition: color 0.2s; }
        .delete-row-btn:hover { color: #f44336; }
        .results-table { border-collapse: collapse; width: 100%; }
        .results-table th, .results-table td { padding: 6px 8px; text-align: center; border-bottom: 1px solid #f2f2f2; font-size: 0.6rem; font-weight: 300; white-space: nowrap; }
        .results-table th { background-color: #e0e0e0; color: #333; font-weight: 300; text-transform: uppercase; font-size: 0.6rem; text-align: center; position: sticky; top: 0; z-index: 10; }
        .results-table td:nth-child(1), .results-table td:nth-child(2) { text-align: left; }
        .results-table th:nth-child(1), .results-table th:nth-child(2) { text-align: left; }
        .results-table td:nth-child(14) { text-align: center; font-weight: 300; color: #222; font-size: 0.6rem; }
        .results-table tbody tr:last-child td { border-bottom: none; }
        .results-table tbody tr:hover { background-color: #fdfdfd; }
        .positive-value { color: #28a745; font-weight: 500; }
        .negative-value { color: #dc3545; font-weight: 500; }
        .neutral-value { color: #333; }
        .detail-section { background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 10px; padding: 1.2rem; box-shadow: 0 2px 10px rgba(0,0,0,0.05); font-size: 0.75rem; }
        .detail-section.active { opacity: 1; transform: translateY(0); }
        .detail-label { font-weight: 600; color: #2a2a2a; margin-right: 0.5rem; }
        .detail-value { color: #555; }
        .error-message { background-color: #fdeaea; color: #dc3545; border: 1px solid #f5c6cb; border-radius: 6px; padding: 8px; font-size: 0.75rem; margin-top: 1rem; }
        /* Custom scrollbar for input rows container */
        #inputRowsContainer { max-height: 400px; overflow-y: auto; padding-right: 8px; margin-bottom: 1.5rem; }
        #inputRowsContainer::-webkit-scrollbar { width: 8px; }
        #inputRowsContainer::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 10px; }
        #inputRowsContainer::-webkit-scrollbar-thumb { background: #d0d0d0; border-radius: 10px; }
        #inputRowsContainer::-webkit-scrollbar-thumb:hover { background: #b0b0b0; }
        /* Styles for the table cell containing action buttons in active plans */
        .action-buttons-cell { display: flex; justify-content: center; align-items: center; gap: 0.4rem; }
        /* Styles for the new action buttons in active plans */
        .action-button-small { background-color: #222222; color: white; padding: 0.3rem 0.6rem; border-radius: 4px; font-weight: 500; font-size: 0.6rem; transition: background-color 0.2s, opacity 0.2s; white-space: nowrap; border: 1px solid #111111; }
        .action-button-small:hover { opacity: 0.8; }

        /* Specific font size for main titles */
        h1.text-3xl { font-size: 1.25rem; font-weight: 200; }
        /* Adjusted font size for h2 titles in statistics sections */
        h2.text-lg { font-size: 0.8rem; font-weight: 300; }
        /* New style for modal title */
        #photoUploadModal h3 { font-size: 0.9rem; font-weight: 600; color: #2a2a2a; }
        p.text-sm { font-size: 0.7rem; font-weight: 200; }
        
        /* --- NEW: 16:9 Gallery Styles --- */
        .gallery-16x9-container { overflow-x: auto; white-space: nowrap; -webkit-overflow-scrolling: touch; scroll-behavior: smooth; cursor: pointer; }
        .gallery-16x9-container::-webkit-scrollbar { display: none; } /* Hide scrollbar */
        .gallery-16x9-slide { display: inline-block; width: 100%; height: auto; aspect-ratio: 16 / 9; object-fit: cover; }
        .gallery-16x9-wrapper { position: relative; background-color: #f0f0f0; border: 1px solid #cccccc; }
        
        /* --- UPDATE: Old 1:1 Gallery Styles --- */
        .photo-gallery-container { position: relative; display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 400px; margin: 0 auto; }
        #photoCarousel { width: 100%; aspect-ratio: 1 / 1; border-radius: 8px; border: 1px solid #cccccc; object-fit: cover; cursor: pointer; overflow-x: auto; /* Enable horizontal scroll */ white-space: nowrap; /* Keep images in one line */ -webkit-overflow-scrolling: touch; scroll-behavior: smooth; }
        #photoCarousel::-webkit-scrollbar { display: none; } /* Hide scrollbar for cleaner look */
        #photoSlides { display: inline-flex; /* Use inline-flex to align items in a row */ height: 100%; }
        #photoSlides img { width: 400px; /* Fixed width to match container */ height: 100%; object-fit: cover; flex-shrink: 0; }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container-wrapper { padding: 1rem; margin-top: 5rem; }
            .header-global { padding: 1rem 1.5rem; }
            .header-global span, .header-global a { font-size: 0.75rem; }
            .header-section { padding: 1.5rem 1rem; margin-left: -1rem; margin-right: -1rem; }
            h1.text-3xl { font-size: 1.1rem; }
            h2.text-lg { font-size: 0.8rem; }
            .input-row { padding: 1rem; }
            .input-label, .input-field, .select-field, .input-group-percent span, .buy-button, .sell-button, .action-button, .results-table th, .results-table td { font-size: 0.75rem; }
            .action-button { padding: 0.5rem 0.8rem; }
            .action-button-small { padding: 0.2rem 0.4rem; font-size: 0.6rem; }
            .grid-cols-1.sm:grid-cols-2.md:grid-cols-3.lg:grid-cols-6 { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
            .top-left-photo-section { flex-direction: column; align-items: center; gap: 0.5rem; padding-left: 0; padding-top: 0; }
            #executedTradingPlansSection > div.flex { flex-direction: column; align-items: flex-start; gap: 0.75rem; }
            #executedTradingPlansSection > div.flex > h2 { margin-bottom: 0; }
            #executedTradingPlansSection > div.flex > div.flex { flex-direction: row; width: 100%; justify-content: flex-start; }
            .photo-gallery-container { width: 100%; max-width: none; }
            #photoCarousel { width: 100%; height: auto; aspect-ratio: 1 / 1; }
            #photoSlides img { width: 100%; height: 100%; object-fit: cover; }
            #dailyLineChartContainer, #monthlyBarChartContainer, #overallPercentageCumulativeChartContainer, #overallBalanceCumulativeChartContainer, #overallPipsCumulativeChartContainer, #tradeFrequencyChartContainer { padding: 1rem; min-height: 220px; }
            #pieChartContainer { padding: 1rem; min-height: 280px; }
            .gallery-16x9-wrapper { margin-left: -1rem; margin-right: -1rem; } /* Full screen on mobile */
        }

        @media (min-width: 769px) {
            .header-global { padding: 2rem 2.5rem; }
            .top-left-photo-section { justify-content: center; } /* Removed flex-direction: row */
            .photo-gallery-container { max-width: 400px; }
            #executedTradingPlansSection > div.flex { flex-direction: row; justify-content: space-between; }
            #executedTradingPlansPlansSection > div.flex > div.flex { width: auto; }
        }

        /* Ensure tables are horizontally scrollable on small screens */
        .overflow-x-auto { overflow-x: auto; }
        /* Styles for download buttons */
        .download-buttons { display: flex; gap: 0.5rem; margin-top: 1rem; justify-content: flex-end; display: none; }
        .download-button { background-color: #222222; color: #ffffff; padding: 0.4rem 0.8rem; border-radius: 6px; font-weight: 500; font-size: 0.75rem; cursor: pointer; border: none; }
        .download-button.pdf { background-color: #222222; }
        .download-button:hover { opacity: 0.9; }
        .download-button:active { transform: translateY(0); }
        
        /* New styles for the top-left photo and button container */
        .top-left-photo-section { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; margin-bottom: 1.5rem; }
        
        /* Added style for executed plans table container to enable vertical scrolling */
        #executedPlansTableContainer { max-height: 300px; overflow-y: auto; border-radius: 0.5rem; border: 1px solid #e0e0e0; }
        #executedPlansTableContainer::-webkit-scrollbar { width: 8px; }
        #executedPlansTableContainer::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 10px; }
        #executedPlansTableContainer::-webkit-scrollbar-thumb { background: #d0d0d0; border-radius: 10px; }
        #executedPlansTableContainer::-webkit-scrollbar-thumb:hover { background: #b0b0b0; }

        /* --- Animasi Scroll (Fade-in-up) --- */
        .scroll-animate-section { opacity: 0; transform: translateY(50px); transition: opacity 0.6s ease-out, transform 0.6s ease-out; }
        .scroll-animate-section.scrolled-into-view { opacity: 1; transform: translateY(0); }

        /* Adjusted Pie Chart Container for a balanced size */
        #pieChartContainer { min-height: 220px; max-width: 350px; margin: 0 auto; }

        /* Ensure canvas itself is responsive within its container */
        #assetSuccessPieChart { width: 100% !important; height: auto !important; }

        /* Styling for the new informational text section */
        .info-section { background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 12px; padding: 2rem; margin-top: 2rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03); }
        .info-section h2 { font-size: 1.25rem; font-weight: 500; color: #2a2a2a; margin-bottom: 1rem; border-bottom: 1px solid #e8e8e8; padding-bottom: 0.5rem; }
        .info-section h3 { font-size: 1rem; font-weight: 600; color: #333; margin-top: 1.5rem; margin-bottom: 0.75rem; }
        .info-section p { font-size: 0.875rem; font-weight: 300; color: #555; line-height: 1.6; margin-bottom: 1rem; }
        .info-section ul { list-style-type: disc; margin-left: 1.5rem; margin-bottom: 1rem; }
        .info-section ul li { font-size: 0.875rem; font-weight: 300; color: #555; margin-bottom: 0.5rem; }
        .info-section strong { font-weight: 500; color: #333; }
        .info-section .list-circle { list-style-type: circle; }

        /* New style for numbers in Overall Summary Statistics */
        #overallSummaryStatisticsSection p.text-base { font-weight: 300; color: #222222; }
        #overallSummaryStatisticsSection p.text-base.negative-summary-value { color: #dc3545; }

        /* New style for numbers in Risk and Reward Statistics */
        #riskRewardStatisticsSection p.text-base { font-weight: 300; color: #222222; }
        #riskRewardStatisticsSection p.text-lg { font-weight: 300; color: #222222; }

        /* Modal specific styles */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal.show { opacity: 1; visibility: visible; }
        .modal-content { background-color: #ffffff; padding: 2rem; border-radius: 12px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); width: 90%; max-width: 500px; position: relative; transform: translateY(-20px); transition: transform 0.3s ease; }
        .modal.show .modal-content { transform: translateY(0); }
        .modal-close-button { position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #999; }
        .modal-close-button:hover { color: #333; }

        /* Adjustments for image cropping canvas in modal */
        #photoUploadModal .flex.justify-center.items-center { width: 100%; max-width: 400px; margin: 1rem auto; }
        #imageCanvas { width: 100%; height: auto; display: block; border-radius: 8px; }

        /* --- NEW: Styles for Monthly Summary Table --- */
        .monthly-summary-table th, .monthly-summary-table td { font-size: 0.55rem; padding: 4px 6px; }
        .monthly-summary-table th { font-weight: 400; text-align: center; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    <!-- Global Header for the entire page (fixed at top) -->
    <div class="header-global">
        <div class="flex items-center gap-5">
            <span class="text-sm font-light">Beranda Utama</span>
        </div>
        <div class="text-center absolute left-1/2 -translate-x-1/2">
            <span id="currentDateHeader" class="text-sm"></span>
            <span id="currentTimeHeader" class="text-sm"></span>
        </div>
        
        <!-- Desktop Navigation -->
        <nav class="hidden md:flex items-center gap-5">
            <a href="index.html" class="text-sm font-light hover:underline">Home</a>
            <a href="about_new.html" class="text-sm font-light hover:underline">About</a>
            <a href="services.html" class="text-sm font-light hover:underline">Services</a>
            <a href="contact.html" class="text-sm font-light hover:underline">Contact</a>
            <a href="investasi.html" class="text-sm font-light hover:underline">Investasi</a>
            <a href="backtest.html" class="text-sm font-light hover:underline">Backtest</a>
        </nav>

        <!-- Hamburger Menu Button for Mobile -->
        <div class="md:hidden">
            <button id="hamburgerBtn" class="focus:outline-none">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
            </button>
        </div>
    </div>

    <!-- Mobile Menu (Initially Hidden) -->
    <div id="mobileMenu" class="hidden fixed inset-0 bg-white z-50 p-6 transition-transform duration-300 ease-in-out">
        <div class="flex justify-between items-center mb-8">
            <span class="text-lg font-semibold">Menu</span>
            <button id="closeMenuBtn" class="focus:outline-none">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="text-center text-gray-600 mb-8">
            <div id="mobileMenuDateTime"></div>
        </div>
        <nav class="flex flex-col items-center space-y-4">
            <a href="index.html" class="text-lg text-gray-700 hover:text-blue-600">Home</a>
            <a href="about_new.html" class="text-lg text-gray-700 hover:text-blue-600">About</a>
            <a href="services.html" class="text-lg text-gray-700 hover:text-blue-600">Services</a>
            <a href="contact.html" class="text-lg text-gray-700 hover:text-blue-600">Contact</a>
            <a href="investasi.html" class="text-lg text-gray-700 hover:text-blue-600">Investasi</a>
            <a href="backtest.html" class="text-lg text-gray-700 hover:text-blue-600">Backtest</a>
        </nav>
    </div>

    <div class="container-wrapper rounded-xl shadow-lg">
        <!-- NEW: 16:9 Photo Gallery Section -->
        <section class="mb-8 scroll-animate-section">
            <div class="gallery-16x9-wrapper">
                <div id="gallery16x9Container" class="gallery-16x9-container">
                    <!-- 16:9 images will be dynamically loaded here -->
                    <img src="https://placehold.co/1920x1080/cccccc/ffffff?text=Add+16:9+Photos" alt="Placeholder 16:9" class="gallery-16x9-slide">
                </div>
            </div>
            <label for="imageInput16x9" class="mt-4 block text-center light-action-button w-full cursor-pointer">Tambah Foto 16:9</label>
        </section>


        <!-- OLD: 1:1 Photo Gallery Section (Modified) -->
        <section class="top-left-photo-section scroll-animate-section">
            <div class="photo-gallery-container relative w-full max-w-sm mx-auto flex flex-col items-center">
                 <div id="photoCarousel" class="relative bg-gray-100 flex items-center justify-center w-full">
                    <div id="photoSlides" class="flex">
                        <!-- 1:1 Images will be dynamically loaded here -->
                        <img src="https://placehold.co/400x400/cccccc/ffffff?text=Add+Photos" alt="Placeholder" class="w-full h-full object-cover flex-shrink-0">
                    </div>
                    <!-- Tombol navigasi disembunyikan sesuai permintaan -->
                    <div id="photoCounter" class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded-full hidden"></div>
                </div>
                <label for="imageInput" class="mt-4 block text-center light-action-button w-full cursor-pointer">Tambah Foto 1:1</label>
            </div>
        </section>

        <header class="header-section text-center mb-8 rounded-t-xl scroll-animate-section">
            <h1 class="text-3xl font-extralight text-primary mb-2">Risk & Reward Calculator</h1>
            <p class="text-gray-600 text-sm font-extralight">
                <span id="currentDate"></span>, <span id="currentTime"></span>
            </p>
        </header>

        <!-- Notification for trade limits -->
        <div id="limitNotification" class="hidden text-center p-3 rounded-lg error-message mb-4"></div>

        <section id="calculatorInputs" class="mb-8 scroll-animate-section">
            <div id="inputRowsContainer" class="space-y-6">
                <!-- Input rows will be dynamically added here -->
            </div>

            <div class="flex flex-col sm:flex-row gap-4 mt-6">
                <button id="addInputRowBtn" class="w-full sm:flex-1 action-button">
                    Tambah Baris Input
                </button>
                <button id="calculateAllBtn" class="w-full sm:flex-1 action-button">
                    Hitung Semua
                </button>
            </div>
        </section>

        <!-- New section for Calculated/New Trading Plans -->
        <section id="newTradingPlansSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">Rencana Trading Baru</h2>
            <div class="overflow-x-auto rounded-lg border border-gray-200">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Aset</th><th>Trade</th><th>Balance Akun</th><th>Waktu Masuk</th><th>Open Price</th><th>SL Price</th><th>TP Price</th><th>Pending Pips/Points</th><th>SL Pips/Points</th><th>TP Pips/Points</th><th>R:R Pips</th><th>R:R %</th><th>Lot/Units</th><th>Nett SL</th><th>Nett TP</th><th>Catatan</th><th class="rounded-tr-lg">Aksi</th>
                        </tr>
                    </thead>
                    <tbody id="calculatedPlansBody">
                        <tr><td colspan="17" class="py-4 text-center text-gray-500">Belum ada rencana trading baru.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Existing section, renamed to Rencana Trading Aktif -->
        <section id="runningTradingPlansSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">Rencana Trading Aktif</h2>
            <div class="overflow-x-auto rounded-lg border border-gray-200">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Aset</th><th>Trade</th><th>Balance Akun</th><th>Waktu Masuk</th><th>Open Price</th><th>SL Price</th><th>TP Price</th><th>Pending Pips/Points</th><th>SL Pips/Points</th><th>TP Pips/Points</th><th>R:R Pips</th><th>R:R %</th><th>Lot/Units</th><th>Nett SL</th><th>Nett TP</th><th>Catatan</th><th class="rounded-tr-lg">Aksi</th>
                        </tr>
                    </thead>
                    <tbody id="runningPlansBody">
                        <tr><td colspan="17" class="py-4 text-center text-gray-500">Belum ada rencana trading aktif.</td></tr>
                    </tbody>
                </table>
            </div>
            <div id="calculationDetails" class="mt-6 hidden">
                <!-- Calculation details will be displayed here, but hidden by default now -->
            </div>
        </section>

        <section id="executedTradingPlansSection" class="mt-8 scroll-animate-section">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4 pb-2 border-b border-gray-200">
                <h2 class="text-lg font-extralight text-primary mb-2 sm:mb-0">Rencana Trading Selesai</h2>
                <div class="flex gap-3 mt-2 sm:mt-0">
                    <!-- NEW: "Unduh Excel" button added here -->
                    <button id="downloadExecutedExcelBtn" class="upload-data-button">Unduh Excel</button>
                    <button id="uploadDataBtn" class="upload-data-button">Unggah Data</button>
                    <button id="deleteAndExportDataBtn" class="delete-data-button">Hapus Data</button>
                </div>
            </div>
            <!-- Added a wrapper div for vertical scrolling -->
            <div id="executedPlansTableContainer" class="overflow-x-auto">
                <table class="results-table" id="executedPlansTable">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Aset</th><th>Trade</th><th>Balance Akun</th><th>Waktu Masuk</th><th>Open Price</th><th>SL Price</th><th>TP Price</th><th>Pending Pips/Points</th><th>SL Pips/Points</th><th>TP Pips/Points</th><th>R:R Pips</th><th>R:R %</th><th>Lot/Units</th><th>Nett SL</th><th>Nett TP</th><th>Catatan</th><th>Hasil</th><th class="rounded-tr-lg">Waktu Keluar</th>
                        </tr>
                    </thead>
                    <tbody id="executedPlansBody">
                        <tr><td colspan="18" class="py-4 text-center text-gray-500">Belum ada rencana trading yang selesai.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- NEW: Compounding Simulator Section -->
        <section id="compoundingSimulatorSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Simulator Compounding</h2>
            <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 md:grid-cols-4 gap-6">
                <div>
                    <label for="simBalance" class="block text-sm input-label mb-1">Balance Awal ($)</label>
                    <input type="number" id="simBalance" placeholder="Cth: 5000" class="mt-1 block w-full input-field">
                </div>
                <div>
                    <label for="simRiskPerTrade" class="block text-sm input-label mb-1">Risk per Trade (%)</label>
                    <input type="number" id="simRiskPerTrade" placeholder="Cth: 0.5" step="0.01" class="mt-1 block w-full input-field">
                </div>
                <div>
                    <label for="simMonthlyTarget" class="block text-sm input-label mb-1">Target Bulanan (%)</label>
                    <input type="number" id="simMonthlyTarget" placeholder="Cth: 5" step="0.1" class="mt-1 block w-full input-field">
                </div>
                <div>
                    <label for="simPeriod" class="block text-sm input-label mb-1">Periode Simulasi (Bulan)</label>
                    <input type="number" id="simPeriod" placeholder="Cth: 12" class="mt-1 block w-full input-field">
                </div>
            </div>
        </section>


        <!-- New section for Overall Summary Statistics -->
        <section id="overallSummaryStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Statistik Ringkasan Keseluruhan</h2>
            <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 md:grid-cols-6 gap-6 text-center">
                <!-- Row 1 -->
                <div><p class="text-gray-600 text-sm font-light">Total Trade Selesai</p><p id="totalSettledTradesSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Probabilitas</p><p id="probabilitySummary" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Total Pips/Points</p><p id="totalPipsSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata % per Trade</p><p id="avgPercentagePerTradeSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Persentase Harian</p><p id="dailyPercentageSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Persentase Bulanan</p><p id="monthlyPercentageSummary" class="text-base mt-1">N/A</p></div>
                <!-- Row 2 -->
                <div><p class="text-gray-600 text-sm font-light">Persentase Tahunan</p><p id="yearlyPercentageSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Persentase Keseluruhan</p><p id="overallPercentageSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Saldo Akun Akhir</p><p id="finalBalanceSummary" class="text-base mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Waktu Bergabung</p><p id="joinTimeSummary" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Drawdown Saldo</p><p id="balanceDrawdownSummary" class="text-base mt-1">N/A</p></div>
            </div>
        </section>

        <!-- New section for Risk and Reward Statistics -->
        <section id="riskRewardStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Statistik Risiko dan Imbalan</h2>
            <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 text-center">
                <div class="sm:col-span-2 md:col-span-4 flex flex-col sm:flex-row justify-center items-center p-2 rounded-md bg-gray-100">
                    <p class="text-gray-600 text-sm font-light mr-2">Rata-rata Risiko dan Imbalan</p><p id="avgRiskReward" class="text-lg font-light text-black">1 : N/A</p>
                </div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Sinyal Diselesaikan/Bulan</p><p id="avgSignalSettledMonth" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Periode Penahanan</p><p id="avgHoldingPeriod" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata TP Pips</p><p id="avgTpPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata SL Pips</p><p id="avgSlPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Keuntungan Beruntun</p><p id="consecutiveProfit" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Kerugian Beruntun</p><p id="consecutiveLoss" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Pips</p><p id="averagePips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Laba Kotor</p><p id="grossProfit" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rugi Kotor</p><p id="grossLoss" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Rata-rata Sinyal Diselesaikan/Minggu</p><p id="avgSignalSettledWeek" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Periode Penahanan Maks</p><p id="maxHoldingPeriod" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Max TP Pips</p><p id="maxTpPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Max SL Pips</p><p id="maxSlPips" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Balance Drawdown Maximal</p><p id="maxBalanceDrawdown" class="text-base font-light text-black mt-1">N/A</p></div>
                <div><p class="text-gray-600 text-sm font-light">Balance Drawdown Relative</p><p id="relativeBalanceDrawdown" class="text-base font-light text-black mt-1">N/A</p></div>
            </div>
        </section>

        <section id="assetSuccessStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Statistik Keberhasilan Aset</h2>
            <div id="pieChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center">
                <canvas id="assetSuccessPieChart"></canvas>
                <div id="pieChartLoading" class="hidden text-gray-500">Memuat data keberhasilan aset...</div>
                <div id="pieChartError" class="hidden error-message"></div>
                <div id="pieChartNoData" class="hidden text-gray-500">Tidak ada data keberhasilan aset yang tersedia.</div>
            </div>
        </section>

        <section id="dailyLineStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">
                Statistik Persentase Harian <span id="dailyChartDateTime" class="text-gray-600 text-sm font-light"></span>
            </h2>
            <div id="dailyLineChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="dailyLineChart"></canvas>
                <div id="dailyLineChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="dailyLineChartError" class="hidden error-message"></div>
                <div id="dailyLineChartNoData" class="hidden text-gray-500">Tidak ada data statistik harian.</div>
            </div>
        </section>

        <section id="monthlyBarStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Statistik Persentase Bulanan (Diagram Batang)</h2>
            <div id="monthlyBarChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="monthlyBarChart"></canvas>
                <div id="monthlyBarChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="monthlyBarChartError" class="hidden error-message"></div>
                <div id="monthlyBarChartNoData" class="hidden text-gray-500">Tidak ada data statistik bulanan.</div>
            </div>
        </section>

        <section id="overallPercentageCumulativeStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Statistik Persentase Kumulatif Keseluruhan (Acuan Balance)</h2>
            <div id="overallPercentageCumulativeChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="overallPercentageCumulativeChart"></canvas>
                <div id="overallPercentageCumulativeChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="overallPercentageCumulativeChartError" class="hidden error-message"></div>
                <div id="overallPercentageCumulativeChartNoData" class="hidden text-gray-500">Tidak ada data statistik kumulatif keseluruhan.</div>
            </div>
        </section>

        <!-- MODIFIED: Monthly Summary Table Section -->
        <section id="monthlySummaryTableSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200 text-center">Ringkasan Bulanan (Akumulasi)</h2>
            <div class="overflow-x-auto rounded-lg border border-gray-200">
                <table class="results-table w-full monthly-summary-table">
                    <thead>
                        <tr>
                            <th class="rounded-tl-lg">Bulan</th>
                            <th>P/L (%)</th>
                            <th>Total Trade</th>
                            <th class="rounded-tr-lg">Saldo Akhir</th>
                        </tr>
                    </thead>
                    <tbody id="monthlySummaryTableBody">
                        <!-- Initial state before data is loaded -->
                        <tr><td colspan="4" class="py-4 text-center text-gray-500">Memuat data ringkasan...</td></tr>
                    </tbody>
                </table>
            </div>
            <!-- NEW: Download button for monthly summary -->
            <div class="flex justify-end mt-4">
                <button id="downloadMonthlySummaryBtn" class="upload-data-button">Unduh Excel</button>
            </div>
        </section>

        <section id="overallBalanceCumulativeStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Statistik Saldo Akun Kumulatif Keseluruhan</h2>
            <div id="overallBalanceCumulativeChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="overallBalanceCumulativeChart"></canvas>
                <div id="overallBalanceCumulativeChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="overallBalanceCumulativeChartError" class="hidden error-message"></div>
                <div id="overallBalanceCumulativeChartNoData" class="hidden text-gray-500">Tidak ada data statistik saldo kumulatif keseluruhan.</div>
            </div>
        </section>

        <section id="overallPipsCumulativeStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Statistik Pips/Points Kumulatif Keseluruhan</h2>
            <div id="overallPipsCumulativeChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="overallPipsCumulativeChart"></canvas>
                <div id="overallPipsCumulativeChartLoading" class="hidden text-gray-500">Memuat data statistik...</div>
                <div id="overallPipsCumulativeChartError" class="hidden error-message"></div>
                <div id="overallPipsCumulativeChartNoData" class="hidden text-gray-500">Tidak ada data statistik pips/points kumulatif keseluruhan.</div>
            </div>
        </section>

        <!-- New section for Trade Frequency Chart -->
        <section id="tradeFrequencyStatisticsSection" class="mt-8 scroll-animate-section">
            <h2 class="text-lg font-normal text-primary mb-4 pb-2 border-b border-gray-200">Frekuensi Eksekusi Trade per Aset</h2>
            <div id="tradeFrequencyChartContainer" class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]">
                <canvas id="tradeFrequencyChart"></canvas>
                <div id="tradeFrequencyChartLoading" class="hidden text-gray-500">Memuat data frekuensi trade...</div>
                <div id="tradeFrequencyChartError" class="hidden error-message"></div>
                <div id="tradeFrequencyChartNoData" class="hidden text-gray-500">Tidak ada data frekuensi trade.</div>
            </div>
        </section>

        <!-- NEW GUIDE SECTION -->
        <section class="info-section mt-8 scroll-animate-section">
            <h2>Panduan Lengkap: Menggunakan Kalkulator Risk & Reward</h2>
            <p>Selamat datang di Kalkulator Risk & Reward! Alat ini dirancang untuk menjadi asisten pribadi Anda dalam merencanakan, menghitung, dan menganalisis setiap perdagangan. Dengan memahami potensi risiko dan imbalan sebelum masuk pasar, Anda dapat membuat keputusan yang lebih cerdas dan disiplin.</p>
            
            <h3>Langkah-langkah Penggunaan</h3>
            <ol class="list-decimal list-inside space-y-4">
                <li>
                    <strong>Membuat Rencana (Input Data)</strong>
                    <p class="mt-2">Klik tombol <strong>"Tambah Baris Input"</strong> untuk memulai. Sebuah formulir akan muncul. Isi setiap kolom dengan cermat:</p>
                    <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
                        <li><strong>Aset:</strong> Pilih instrumen yang akan Anda perdagangkan dari daftar.</li>
                        <li><strong>Tipe Trade:</strong> Tentukan posisi Anda dengan memilih <strong>BUY</strong> atau <strong>SELL</strong>.</li>
                        <li><strong>Balance Akun ($):</strong> Masukkan total saldo akun trading Anda saat ini.</li>
                        <li><strong>Risiko (%):</strong> Tentukan berapa persen dari saldo akun yang Anda relakan sebagai risiko untuk trade ini (misal: 0.5% atau 1%).</li>
                        <li><strong>Price Now:</strong> Harga pasar saat ini. Kolom ini digunakan untuk menghitung 'Pending Pips' dan tidak memengaruhi kalkulasi inti.</li>
                        <li><strong>Open Price:</strong> Harga di mana Anda berencana untuk membuka posisi.</li>
                        <li><strong>SL Price (Stop Loss):</strong> Harga di mana posisi akan ditutup otomatis untuk membatasi kerugian.</li>
                        <li><strong>TP Price (Take Profit):</strong> Harga di mana posisi akan ditutup otomatis untuk mengamankan keuntungan.</li>
                        <li><strong>Catatan (Opsional):</strong> Tulis catatan singkat mengenai strategi atau alasan Anda membuka posisi ini.</li>
                    </ul>
                </li>
                <li>
                    <strong>Menghitung & Memindahkan Rencana</strong>
                    <p class="mt-2">Setelah semua data terisi, klik <strong>"Hitung Semua"</strong>. Hasil perhitungan akan muncul di tabel <strong>"Rencana Trading Baru"</strong>. Dari sini, alur kerjanya adalah:</p>
                    <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
                        <li><strong>Set Running:</strong> Jika Anda memutuskan untuk melanjutkan rencana ini (sebagai pending atau market order), klik tombol ini. Rencana akan pindah ke tabel <strong>"Rencana Trading Aktif"</strong>.</li>
                        <li><strong>Menyelesaikan Trade:</strong> Di tabel "Rencana Trading Aktif", setelah posisi Anda ditutup, klik <strong>"TAKE PROFIT"</strong> atau <strong>"STOP LOSS"</strong> sesuai hasil akhirnya. Rencana akan pindah ke tabel <strong>"Rencana Trading Selesai"</strong> dan semua data statistik akan diperbarui secara otomatis.</li>
                        <li><strong>Opsi Lain:</strong> Gunakan tombol <strong>"BATAL"</strong> atau <strong>"TES"</strong> untuk membatalkan rencana aktif tanpa perhitungan statistik, atau <strong>"EDIT"</strong> untuk memindahkan kembali rencana ke formulir input jika ada perubahan.</li>
                    </ul>
                </li>
            </ol>

            <h3>Memahami Hasil Kalkulasi</h3>
            <p>Berikut penjelasan untuk setiap kolom di tabel hasil:</p>
            <ul>
                <li><strong>Pending Pips/Points:</strong> Jarak antara <strong>Price Now</strong> dan <strong>Open Price</strong> Anda.</li>
                <li><strong>SL Pips/Points:</strong> Jarak (risiko) dari <strong>Open Price</strong> ke <strong>SL Price</strong>.</li>
                <li><strong>TP Pips/Points:</strong> Jarak (potensi imbalan) dari <strong>Open Price</strong> ke <strong>TP Price</strong>.</li>
                <li><strong>R:R Pips:</strong> Rasio sederhana antara TP Pips dan SL Pips. Contoh: 1:2.5 berarti potensi imbalan 2.5 kali lebih besar dari risikonya.</li>
                <li><strong>R:R %:</strong> Rasio antara persentase potensi profit dan persentase risiko dari total balance.</li>
                <li><strong>Lot/Units:</strong> Ukuran volume trading yang dihitung secara otomatis berdasarkan persentase risiko yang Anda tentukan, memastikan Anda tidak merisikokan lebih dari yang direncanakan.</li>
                <li><strong>Nett SL:</strong> Total potensi kerugian dalam mata uang Dolar jika harga menyentuh Stop Loss.</li>
                <li><strong>Nett TP:</strong> Total potensi keuntungan dalam mata uang Dolar jika harga menyentuh Take Profit.</li>
            </ul>

            <h3>Manajemen Foto & Analisis Data</h3>
            <ul class="list-disc list-inside space-y-2">
                <li><strong>Galeri Foto:</strong> Anda bisa menambahkan hingga 5 screenshot analisis (misal: dari TradingView) dengan mengklik area foto. Untuk menghapus foto, tekan dan tahan (long press) pada gambar yang ingin dihapus.</li>
                <li><strong>Statistik & Grafik:</strong> Semua bagian di bawah tabel "Rencana Trading Selesai" adalah rekapitulasi performa Anda. Gunakan grafik ini untuk menganalisis aset mana yang paling menguntungkan, bagaimana pertumbuhan akun Anda, dan kapan Anda paling sering profit atau loss.</li>
                <li><strong>Penting:</strong> Kalkulator ini adalah alat bantu jurnal dan analisis. Keputusan trading dan segala risikonya tetap menjadi tanggung jawab Anda sepenuhnya.</li>
            </ul>
        </section>

        <!-- New section for the provided text content -->
        <section class="info-section mt-8 scroll-animate-section">
            <h2 class="text-xl font-medium text-primary mb-4">Bagaimana Kasino Vegas Membuat Pemain Rugi & Mirip dengan Broker Curang</h2>
            <p class="text-base font-light text-gray-700 leading-relaxed mb-4">Baik kasino di Las Vegas maupun beberapa broker "nakal" memiliki strategi tersembunyi untuk memastikan keuntungan mereka, seringkali dengan mengorbankan pemain atau trader yang menguntungkan. Meskipun metode mereka berbeda, prinsip dasarnya sama: memanipulasi probabilitas dan informasi untuk keuntungan mereka.</p>
            <h3 class="text-lg font-semibold text-gray-800 mb-3">Alur Kasino Vegas Membuat Pemain Rugi</h3>
            <p class="text-base font-light text-gray-700 leading-relaxed mb-4">Kasino tidak perlu "curang" secara terang-terangan untuk menang; model bisnis mereka dibangun di atas keunggulan statistik yang disebut "house edge". Ini adalah persentase keuntungan jangka panjang yang dimiliki kasino atas pemain. Berikut adalah alurnya:</p>
            <ul class="list-disc list-inside mb-4">
                <li class="text-base font-light text-gray-700 mb-2"><strong>Matematika yang Tidak Menguntungkan Pemain (House Edge):</strong> Setiap permainan kasino dirancang agar kasino selalu memiliki sedikit keuntungan matematis dalam jangka panjang. Misalnya, di rolet, ada angka 0 (dan kadang 00), yang berarti peluang Anda untuk memenangkan taruhan merah/hitam sedikit kurang dari 50%. Meskipun Anda mungkin menang beberapa putaran, secara statistik, kasino akan selalu di atas angin seiring waktu.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Variasi dan Keberuntungan Jangka Pendek:</strong> Kasino mengandalkan fakta bahwa dalam jangka pendek, keberuntungan bisa berpihak pada pemain. Ini menciptakan ilusi bahwa pemain bisa menang besar, mendorong mereka untuk terus bermain. Kemenangan sesekali ini memicu dopamin dan membuat pemain merasa "beruntung," mendorong mereka untuk terus bertaruh.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Psikologi dan Lingkungan yang Memikat:</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Desain Tanpa Jendela dan Jam: Kasino dirancang untuk membuat pemain lupa waktu, mendorong mereka untuk bermain lebih lama.</li>
                        <li class="text-base font-light text-gray-700">Atmosfer Glamor dan Hiburan: Suasana yang mewah, musik, dan minuman gratis menciptakan lingkungan yang nyaman dan mendorong pengeluaran.</li>
                        <li class="text-base font-light text-gray-700">Kompensasi dan Hadiah (Comp): Kasino memberikan hadiah kecil (makanan gratis, kamar murah) kepada pemain yang kalah dalam jumlah besar atau bermain untuk waktu yang lama, membuat mereka merasa dihargai dan mendorong kunjungan kembali.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Kontrol Informasi dan Aturan Main:</strong> Kasino sepenuhnya mengontrol aturan main, pembayaran, dan informasi yang diberikan kepada pemain. Pemain seringkali tidak menyadari house edge yang sebenarnya atau bagaimana probabilitas bekerja melawan mereka.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Pengelolaan Keuangan Pemain:</strong> Kasino mendorong pemain untuk mengambil lebih banyak uang tunai, menyediakan ATM di lokasi, dan menawarkan fasilitas kredit, semuanya dirancang untuk membuat pemain terus berjudi bahkan setelah mereka kehabisan uang tunai yang mereka bawa.</li>
            </ul>

            <h3 class="text-lg font-semibold text-gray-800 mb-3">Koneksi dengan Broker Curang yang Mencurangi Trader Profitabel</h3>
            <p class="text-base font-light text-gray-700 leading-relaxed mb-4">Meskipun ranahnya berbeda, modus operasi broker nakal yang mencurangi trader profitabel memiliki kemiripan filosofis dengan cara kasino beroperasi. Perbedaannya adalah broker tersebut melakukan tindakan yang lebih eksplisit dan seringkali ilegal.</p>
            <ul class="list-disc list-inside mb-4">
                <li class="text-base font-light text-gray-700 mb-2"><strong>Manipulasi Data dan Eksekusi (House Edge Tersembunyi):</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Slippage yang Tidak Adil: Broker sengaja menerapkan slippage negatif yang besar pada pesanan trader yang profitabel, atau bahkan pada semua pesanan. Ini berarti harga eksekusi jauh lebih buruk dari harga yang diharapkan trader, mengikis keuntungan.</li>
                        <li class="text-base font-light text-gray-700">Requotes dan Penolakan Pesanan: Pesanan trader yang profitabel, terutama pada saat volatilitas tinggi, seringkali ditolak atau di-requote dengan harga yang kurang menguntungkan. Ini mengganggu strategi trading dan menyebabkan frustrasi.</li>
                        <li class="text-base font-light text-gray-700">Pemblokiran Penarikan Dana: Ini adalah bentuk kecurangan yang paling ekstrem. Ketika trader berhasil mengumpulkan keuntungan yang signifikan, broker membuat berbagai alasan (masalah verifikasi, masalah sistem) untuk menunda atau menolak penarikan dana.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Intervensi pada Order Flow (Memprediksi Gerakan Pemain):</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Dealing Desk (DD) vs. Non-Dealing Desk (NDD): Broker DD seringkali mengambil posisi berlawanan dengan trader mereka. Jika seorang trader sangat profitabel, broker DD mungkin akan menempatkan "stop-loss hunting" (memicu stop-loss trader secara artifisial) atau menahan harga yang menguntungkan.</li>
                        <li class="text-base font-light text-gray-700">Manipulasi Harga: Broker dapat memanipulasi feed harga mereka sendiri, terutama saat ada berita penting, untuk memicu stop-loss atau menunda take-profit trader.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Psikologi dan Lingkungan yang Menjebak:</strong>
                    <ul class="list-circle list-inside ml-4 mt-1">
                        <li class="text-base font-light text-gray-700">Bonus dan Promosi Palsu: Banyak broker nakal menawarkan bonus deposit yang sangat besar, tetapi dengan syarat dan ketentuan penarikan yang hampir mustahil untuk dipenuhi. Ini mengunci dana trader dan mendorong mereka untuk terus trading.</li>
                        <li class="text-base font-light text-gray-700">Edukasi yang Menyesatkan: Beberapa broker menyediakan "edukasi" yang pada dasarnya mendorong gaya trading yang tidak sehat atau terlalu agresif, yang pada akhirnya menguntungkan broker karena trader akan lebih sering kalah.</li>
                    </ul>
                </li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Kurangnya Transparansi dan Regulasi yang Lemah:</strong> Broker nakal sering beroperasi di yurisdiksi dengan regulasi yang longgar atau sama sekali tanpa regulasi. Ini memungkinkan mereka untuk melakukan praktik tidak etis tanpa takut dihukum. Mereka tidak memberikan laporan transparan tentang eksekusi order atau aliran dana.</li>
                <li class="text-base font-light text-gray-700 mb-2"><strong>Memanfaatkan Emosi Trader:</strong> Sama seperti kasino, broker nakal memanfaatkan emosi seperti keserakahan dan ketakutan. Mereka tahu bahwa trader yang emosional cenderung membuat keputusan impulsif yang menguntungkan broker.</li>
            </ul>
            <p class="text-base font-light text-gray-700 leading-relaxed">Secara ringkas, baik kasino maupun broker curang bertujuan untuk mendapatkan keuntungan jangka panjang. Kasino melakukannya melalui keunggulan matematis yang inheren dalam permainan mereka dan manipulasi lingkungan psikologis. Broker curang, di sisi lain, secara aktif memanipulasi kondisi trading, data, dan terkadang bahkan menahan dana untuk memastikan mereka "menang" melawan trader yang menguntungkan. Kedua entitas ini mengandalkan fakta bahwa mayoritas "pemain" akan kalah dalam jangka panjang, entah karena matematika atau karena manipulasi sistem.</p>
        </section>

        <!-- NEW: Download All Data Button -->
        <section class="mt-8 text-center scroll-animate-section">
            <button id="downloadAllExcelBtn" class="action-button">Unduh Semua Data (Excel)</button>
        </section>
        
        <!-- Footer Section -->
        <footer class="w-full py-4 text-center text-gray-700 text-sm font-light mt-8">
            Leodra Sint | Think like a dealer, not like a player.
        </footer>
    </div>

    <!-- Photo Upload Modal -->
    <div id="photoUploadModal" class="modal">
        <div class="modal-content">
            <h3 class="text-lg font-semibold text-primary mb-4">Unggah & Pangkas Foto</h3>
            <!-- This input is now visually hidden but triggered by the label -->
            <input type="file" id="imageInput" accept="image/*" class="hidden">
            <input type="file" id="imageInput16x9" accept="image/*" class="hidden">
            <div class="flex justify-center items-center bg-gray-100 rounded-md overflow-hidden">
                <canvas id="imageCanvas"></canvas>
            </div>
            <div class="flex justify-end gap-3 mt-4">
                <button id="cancelPhotoBtn" class="action-button bg-gray-300 hover:bg-gray-400 text-gray-800">Batal</button>
                <button id="cropAndSaveBtn" class="action-button">Pangkas & Simpan</button>
            </div>
        </div>
    </div>

    <!-- PERBAIKAN: Skrip untuk fungsionalitas menu hamburger ditambahkan di sini -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const mobileMenu = document.getElementById('mobileMenu');
            const closeMenuBtn = document.getElementById('closeMenuBtn');

            hamburgerBtn.addEventListener('click', function () {
                mobileMenu.classList.remove('hidden');
            });

            closeMenuBtn.addEventListener('click', function () {
                mobileMenu.classList.add('hidden');
            });
        });
    </script>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, query, onSnapshot, addDoc, deleteDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let storage;
        let userId = 'anonymous'; // Default to anonymous

        // Initialize Firebase
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Global variables for data storage
        let calculatedPlansData = []; // New: for plans that are calculated but not yet running
        let runningPlansData = [];    // Renamed from activePlansData
        let executedPlansData = [];

        // --- DATA ASET & NILAI PIPS/POINTS ---
        // Menambahkan properti 'minLotIncrement' untuk setiap aset
        const assetValues = {
            'EUR/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/USD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/SEK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexMajor', currency: 'SEK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/NOK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexMajor', currency: 'NOK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/DKK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexMajor', currency: 'DKK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/GBP': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexCross', currency: 'GBP', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CAD/JPY': { decimals: 3, pipValue: 9.09, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CHF/JPY': { decimals: 3, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/AUD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexCross', currency: 'AUD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/NZD': { decimals: 5, pipValue: 6.00, contractSize: 100000, type: 'forexCross', currency: 'NZD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/AUD': { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexCross', currency: 'AUD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/NZD': { decimals: 5, pipValue: 6.00, contractSize: 100000, type: 'forexCross', currency: 'NZD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/NZD': { decimals: 5, pipValue: 6.00, contractSize: 100000, type: 'forexCross', currency: 'NZD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CAD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/CAD': { decimals: 5, pipValue: 7.30, contractSize: 100000, type: 'forexCross', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/CHF': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexCross', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/SEK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'SEK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/NOK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'NOK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/SEK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'SEK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/NOK': { decimals: 5, pipValue: 1.00, contractSize: 100000, type: 'forexCross', currency: 'NOK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/MXN': { decimals: 5, pipValue: 0.50, contractSize: 100000, type: 'forexExotic', currency: 'MXN', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/ZAR': { decimals: 5, pipValue: 0.05, contractSize: 100000, type: 'forexExotic', currency: 'ZAR', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/TRY': { decimals: 5, pipValue: 0.03, contractSize: 100000, type: 'forexExotic', currency: 'TRY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'SGD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/HKD': { decimals: 5, pipValue: 1.28, contractSize: 100000, type: 'forexExotic', currency: 'HKD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUR/TRY': { decimals: 5, pipValue: 0.03, contractSize: 100000, type: 'forexExotic', currency: 'TRY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'GBP/TRY': { decimals: 5, pipValue: 0.03, contractSize: 100000, type: 'forexExotic', currency: 'TRY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'SGD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NZD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'SGD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CAD/SGD': { decimals: 5, pipValue: 0.74, contractSize: 100000, type: 'forexExotic', currency: 'CAD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CHF/SGD': { decimals: 5, pipValue: 11.20, contractSize: 100000, type: 'forexExotic', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/PLN': { decimals: 5, pipValue: 0.25, contractSize: 100000, type: 'forexExotic', currency: 'PLN', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/HUF': { decimals: 5, pipValue: 0.003, contractSize: 100000, type: 'forexExotic', currency: 'HUF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'USD/CZK': { decimals: 5, pipValue: 0.04, contractSize: 100000, type: 'forexExotic', currency: 'CZK', minLotIncrement: 0.01, pipsDecimals: 1 },
            'XAU/USD': { decimals: 2, pipValue: 100.00, contractSize: 100, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'XAG/USD': { decimals: 3, pipValue: 50.00, contractSize: 5000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'WTI/USD': { decimals: 2, pipValue: 10.00, contractSize: 1000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'BRENT/USD': { decimals: 2, pipValue: 10.00, contractSize: 1000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NATGAS/USD': { decimals: 3, pipValue: 10.00, contractSize: 10000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'COPPER/USD': { decimals: 4, pipValue: 25000.00, contractSize: 25000, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'PLATINUM/USD': { decimals: 2, pipValue: 50.00, contractSize: 50, type: 'commodity', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'US30': { decimals: 0, pipValue: 1.00, contractSize: 1, type: 'index', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'SPX500': { decimals: 2, pipValue: 50.00, contractSize: 50, type: 'index', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'DAX40': { decimals: 1, pipValue: 25.00, contractSize: 25, type: 'index', currency: 'EUR', minLotIncrement: 0.01, pipsDecimals: 1 },
            'NAS100': { decimals: 2, pipValue: 2.00, contractSize: 2, type: 'index', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'UK100': { decimals: 1, pipValue: 10.00, contractSize: 10, type: 'index', currency: 'GBP', minLotIncrement: 0.01, pipsDecimals: 1 },
            'JP225': { decimals: 1, pipValue: 500.00, contractSize: 500, type: 'index', currency: 'JPY', minLotIncrement: 0.01, pipsDecimals: 1 },
            'AUS200': { decimals: 1, pipValue: 1.00, contractSize: 1, type: 'index', currency: 'AUD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'HK50': { decimals: 1, pipValue: 10.00, contractSize: 10, type: 'index', currency: 'HKD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'FR40': { decimals: 1, pipValue: 1.00, contractSize: 1, type: 'index', currency: 'EUR', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EU50': { decimals: 1, pipValue: 1.00, contractSize: 1, type: 'index', currency: 'EUR', minLotIncrement: 0.01, pipsDecimals: 1 },
            'CHN50': { decimals: 1, pipValue: 1.00, contractSize: 1, type: 'index', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'EUSTX50': { decimals: 1, pipValue: 1.00, contractSize: 1, type: 'index', currency: 'EUR', minLotIncrement: 0.01, pipsDecimals: 1 },
            'SWI20': { decimals: 1, pipValue: 1.00, contractSize: 1, type: 'index', currency: 'CHF', minLotIncrement: 0.01, pipsDecimals: 1 },
            'BTC/USD': { decimals: 2, pipValue: 1.00, contractSize: 1, type: 'crypto', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'ETH/USD': { decimals: 2, pipValue: 1.00, contractSize: 1, type: 'crypto', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'XRP/USD': { decimals: 5, pipValue: 1.00, contractSize: 1, type: 'crypto', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'LTC/USD': { decimals: 2, pipValue: 1.00, contractSize: 1, type: 'crypto', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'ADA/USD': { decimals: 5, pipValue: 1.00, contractSize: 1, type: 'crypto', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'SOL/USD': { decimals: 2, pipValue: 1.00, contractSize: 1, type: 'crypto', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
            'DOGE/USD': { decimals: 6, pipValue: 1.00, contractSize: 1, type: 'crypto', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 },
        };

        // --- GLOBAL VARIABLES DOM ELEMENTS ---
        let rowCounter = 0;
        const inputRowsContainer = document.getElementById('inputRowsContainer');
        const calculatedPlansBody = document.getElementById('calculatedPlansBody'); // New element
        const runningPlansBody = document.getElementById('runningPlansBody'); // Renamed from activePlansData
        const executedPlansBody = document.getElementById('executedPlansBody');
        const calculationDetailsContainer = document.getElementById('calculationDetails');
        const dailyChartDateTime = document.getElementById('dailyChartDateTime');
        const deleteAndExportDataBtn = document.getElementById('deleteAndExportDataBtn');
        const uploadDataBtn = document.getElementById('uploadDataBtn');
        const downloadMonthlySummaryBtn = document.getElementById('downloadMonthlySummaryBtn');
        
        // --- 1:1 Gallery Elements ---
        const photoCarousel = document.getElementById('photoCarousel');
        const photoSlides = document.getElementById('photoSlides');
        const photoCounter = document.getElementById('photoCounter');
        const imageInput = document.getElementById('imageInput');

        // --- NEW 16:9 Gallery Elements ---
        const gallery16x9Container = document.getElementById('gallery16x9Container');
        const imageInput16x9 = document.getElementById('imageInput16x9');
        let autoScrollInterval16x9;

        // --- Modal Elements ---
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const photoUploadModal = document.getElementById('photoUploadModal');
        const cropAndSaveBtn = document.getElementById('cropAndSaveBtn');
        const cancelPhotoBtn = document.getElementById('cancelPhotoBtn');
        
        // --- Photo Management Variables ---
        let currentImageToCrop = null;
        let currentUploadTarget = null; // '1:1' or '16:9'
        let userPhotos = []; // For 1:1 gallery
        let userPhotos16x9 = []; // For 16:9 gallery
        let currentPhotoIndex = 0;
        const MAX_PHOTOS = 5;
        
        // NEW: Download buttons
        const downloadExecutedExcelBtn = document.getElementById('downloadExecutedExcelBtn');
        const downloadAllExcelBtn = document.getElementById('downloadAllExcelBtn');

        // Global Chart instances (will be managed by IntersectionObserver)
        let dailyLineChart = null, monthlyBarChart = null, assetPieChart = null, overallPercentageCumulativeChart = null, overallBalanceCumulativeChart = null, overallPipsCumulativeChart = null, tradeFrequencyChart = null;

        // --- Risk Management Constants ---
        const MONTHLY_LOSS_LIMIT = -4; // in percentage
        const DAILY_LOSS_LIMIT = -2; // in percentage
        const OVERALL_MAX_LOSS_LIMIT = -5; // in percentage
        const MAX_RISK_PER_TRADE = 0.3; // in percentage // CHANGED FROM 0.2 TO 0.3
        let limitNotificationMessage = '';

        // --- HELPER FUNCTIONS ---
        // Modified formatNumber to control thousands grouping
        const formatNumber = (value, decimals = 2, useGrouping = true) => {
            if (isNaN(value) || value === null || !isFinite(value)) return 'N/A';
            const num = parseFloat(value);
            if (useGrouping) {
                // Use toLocaleString for grouping (e.g., for currency, balance, etc.)
                return num.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
            } else {
                // Use toFixed for raw numerical string with specified decimals, no grouping
                return num.toFixed(decimals);
            }
        };

        const formatCurrency = (value, currency = 'USD') => (isNaN(value) || value === null || !isFinite(value)) ? 'N/A' : parseFloat(value).toLocaleString('en-US', { style: 'currency', currency: currency, minimumFractionDigits: 2, maximumFractionDigits: 2 });
        const getColoredValueHtml = (value, isCurrency = false, decimals = 2) => {
            if (value === 'N/A' || isNaN(value) || !isFinite(value)) return `<span class="text-black">N/A</span>`;
            const formattedValue = isCurrency ? formatCurrency(value, 'USD') : formatNumber(value, decimals);
            const colorClass = value >= 0 ? 'text-black' : 'text-red-500';
            return `<span class="${colorClass}">${formattedValue}</span>`;
        };
        function updateDateTime() {
            const now = new Date();
            const dateOptions = { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' };
            const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
            const fullDateTimeString = `${now.toLocaleDateString('id-ID', dateOptions)} ${now.toLocaleTimeString('id-ID', timeOptions)}`;
            
            document.getElementById('currentDate').textContent = now.toLocaleDateString('id-ID', dateOptions);
            document.getElementById('currentTime').textContent = now.toLocaleTimeString('id-ID', timeOptions);
            document.getElementById('currentDateHeader').textContent = now.toLocaleDateString('id-ID', dateOptions);
            document.getElementById('currentTimeHeader').textContent = now.toLocaleTimeString('id-ID', timeOptions);
            if (dailyChartDateTime) dailyChartDateTime.textContent = `(${fullDateTimeString})`;
            
            // Update date/time in mobile menu
            const mobileMenuDateTime = document.getElementById('mobileMenuDateTime');
            if (mobileMenuDateTime) {
                mobileMenuDateTime.textContent = fullDateTimeString;
            }
        }
        const getRandomColor = (index) => `hsl(${(index * 137.508) % 360}, 70%, 50%)`;
        function formatDuration(milliseconds) {
            if (isNaN(milliseconds) || milliseconds < 0) return 'N/A';
            const seconds = Math.floor(milliseconds / 1000);
            const days = Math.floor(seconds / (3600 * 24));
            const hours = Math.floor((seconds % (3600 * 24)) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;
            let result = '';
            if (days > 0) result += `${days} Days `;
            result += `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
            return result.trim();
        }

        // Fungsi pembantu baru untuk mengatur atribut step
        function getStepValue(decimals) {
            if (decimals <= 0) return '1'; // Untuk bilangan bulat
            return '0.' + '0'.repeat(decimals - 1) + '1';
        }

        /**
         * START OF FIX: Updated pips/points formatting and calculation logic.
         * This function now formats the visual display AND provides the value for calculation.
         * @param {number} pipsValue The precise pips value (e.g., 12.5).
         * @returns {{display: string, forCalc: number}} An object with the display string and the number for calculation.
         */
        function getVisualPoints(pipsValue) {
            if (isNaN(pipsValue) || pipsValue === null || !isFinite(pipsValue)) {
                return { display: 'N/A', forCalc: 0 };
            }
            // 1. Convert pips (e.g., 12.5) to points string (e.g., "125")
            const pointsString = Math.round(Math.abs(parseFloat(pipsValue)) * 10).toString();

            // 2. Get the visual part by removing the last character
            const visualString = pointsString.length > 1 ? pointsString.slice(0, -1) : pointsString;
            
            // 3. Parse the visual part for calculation
            const forCalc = parseInt(visualString, 10) || 0;

            return {
                display: visualString,
                forCalc: forCalc
            };
        }

        // Helper functions for modals
        function showModal(modalElement) { modalElement.classList.add('show'); }
        function hideModal(modalElement) { modalElement.classList.remove('show'); }

        /**
         * Displays a custom modal message box.
         * @param {string} title The title of the message box.
         * @param {string} message The main message content.
         * @param {boolean} isConfirm If true, shows "Batal/Ya" buttons and returns a Promise. If false, shows "OK" button.
         * @returns {Promise<boolean>|void} Returns a Promise resolving to true/false for confirm, or void for alert.
         */
        function showMessageBox(title, message, isConfirm = false) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <button class="modal-close-button" id="closeMessageBoxBtn">X</button>
                        <h3 class="text-lg font-semibold text-primary mb-4">${title}</h3>
                        <p class="text-gray-700 mb-6">${message}</p>
                        <div class="flex justify-center gap-3 mt-4">
                            ${isConfirm ? `
                                <button id="cancelMessageBoxBtn" class="action-button bg-gray-300 hover:bg-gray-400 text-gray-800">Batal</button>
                                <button id="confirmMessageBoxBtn" class="action-button bg-blue-600 hover:bg-blue-700">Ya</button>
                            ` : `
                                <button id="okMessageBoxBtn" class="action-button bg-blue-600 hover:bg-blue-700">OK</button>
                            `}
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                showModal(modal);

                const closeBtn = modal.querySelector('#closeMessageBoxBtn');
                const okBtn = modal.querySelector('#okMessageBoxBtn');
                const cancelBtn = modal.querySelector('#cancelMessageBoxBtn');
                const confirmBtn = modal.querySelector('#confirmMessageBoxBtn');

                const hideAndResolve = (result) => {
                    hideModal(modal);
                    modal.addEventListener('transitionend', () => modal.remove(), { once: true });
                    resolve(result);
                };

                if (closeBtn) closeBtn.addEventListener('click', () => hideAndResolve(false));
                if (okBtn) okBtn.addEventListener('click', () => hideAndResolve(true));
                if (cancelBtn) cancelBtn.addEventListener('click', () => hideAndResolve(false));
                if (confirmBtn) confirmBtn.addEventListener('click', () => hideAndResolve(true));
            });
        }


        // --- FIREBASE STORAGE FUNCTIONS ---
        async function loadProfilePictures(uid, galleryType) {
            if (!storage) {
                console.warn("Firebase Storage is not initialized.");
                if (galleryType === '1:1') {
                    loadPhotosFromLocalStorage('1:1');
                    renderPhotoGallery();
                } else {
                    loadPhotosFromLocalStorage('16:9');
                    renderPhotoGallery16x9();
                }
                return;
            }
            const photoArray = galleryType === '1:1' ? userPhotos : userPhotos16x9;
            photoArray.length = 0; // Clear the array
            const loadPromises = [];
            for (let i = 0; i < MAX_PHOTOS; i++) {
                const imageRef = ref(storage, `artifacts/${appId}/users/${uid}/gallery_${galleryType}_${i}.png`);
                loadPromises.push(getDownloadURL(imageRef)
                    .then(url => ({ url, index: i }))
                    .catch(error => null)
                );
            }
            const results = await Promise.all(loadPromises);
            results.forEach(result => {
                if (result) photoArray[result.index] = result.url;
            });
            // Filter out empty slots
            if (galleryType === '1:1') userPhotos = userPhotos.filter(Boolean);
            else userPhotos16x9 = userPhotos16x9.filter(Boolean);

            console.log(`Profile pictures loaded for ${galleryType}:`, photoArray.length);
            if (galleryType === '1:1') renderPhotoGallery();
            else renderPhotoGallery16x9();
            savePhotosToLocalStorage(galleryType);
        }

        async function saveProfilePicture(uid, imageDataUrl, index, galleryType) {
            if (!storage) {
                console.warn("Firebase Storage is not initialized.");
                const photoArray = galleryType === '1:1' ? userPhotos : userPhotos16x9;
                photoArray[index] = imageDataUrl;
                savePhotosToLocalStorage(galleryType);
                if (galleryType === '1:1') renderPhotoGallery();
                else renderPhotoGallery16x9();
                return;
            }
            try {
                const imageRef = ref(storage, `artifacts/${appId}/users/${uid}/gallery_${galleryType}_${index}.png`);
                const response = await fetch(imageDataUrl);
                const blob = await response.blob();
                await uploadBytes(imageRef, blob);
                const photoArray = galleryType === '1:1' ? userPhotos : userPhotos16x9;
                photoArray[index] = imageDataUrl;
                console.log(`Picture gallery_${galleryType}_${index}.png saved.`);
                showMessageBox('Berhasil', 'Foto berhasil disimpan.', false);
                if (galleryType === '1:1') renderPhotoGallery();
                else renderPhotoGallery16x9();
            } catch (error) {
                console.error(`Error saving picture gallery_${galleryType}_${index}.png:`, error);
                showMessageBox('Gagal', 'Terjadi kesalahan saat menyimpan foto.', false);
            }
        }

        async function deleteProfilePicture(uid, indexToDelete, galleryType) {
            const photoArray = galleryType === '1:1' ? userPhotos : userPhotos16x9;
            if (!storage) {
                console.warn("Firebase Storage is not initialized.");
                photoArray.splice(indexToDelete, 1);
                savePhotosToLocalStorage(galleryType);
                if (galleryType === '1:1') renderPhotoGallery();
                else renderPhotoGallery16x9();
                return;
            }
            try {
                const imageRef = ref(storage, `artifacts/${appId}/users/${uid}/gallery_${galleryType}_${indexToDelete}.png`);
                await deleteObject(imageRef);
                console.log(`Picture gallery_${galleryType}_${indexToDelete}.png deleted.`);
                photoArray.splice(indexToDelete, 1);
                // Re-indexing is complex and prone to race conditions. A simpler approach is to just re-upload the remaining photos under new indices.
                const uploadPromises = photoArray.map((url, i) => {
                    const newRef = ref(storage, `artifacts/${appId}/users/${uid}/gallery_${galleryType}_${i}.png`);
                    return fetch(url).then(res => res.blob()).then(blob => uploadBytes(newRef, blob));
                });
                // Delete the last, now orphaned, photo in storage
                if (photoArray.length > 0) {
                    const lastOldRef = ref(storage, `artifacts/${appId}/users/${uid}/gallery_${galleryType}_${photoArray.length}.png`);
                    try { await deleteObject(lastOldRef); } catch (e) { /* ignore if not found */ }
                }

                await Promise.all(uploadPromises);
                
                savePhotosToLocalStorage(galleryType);
                if (galleryType === '1:1') renderPhotoGallery();
                else renderPhotoGallery16x9();
            } catch (error) {
                console.error("Error deleting picture from Firebase:", error);
                photoArray.splice(indexToDelete, 1);
                savePhotosToLocalStorage(galleryType);
                if (galleryType === '1:1') renderPhotoGallery();
                else renderPhotoGallery16x9();
            }
        }

        // --- FIREBASE FIRESTORE FUNCTIONS (No changes needed here for photo functionality) ---
        async function loadCalculatedPlans(uid) {
            if (!db) return;
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/calculatedPlans`));
                onSnapshot(q, (snapshot) => {
                    calculatedPlansData = snapshot.docs.map(doc => {
                        const data = doc.data();
                        data.assetData = getAssetData(data.symbol);
                        return data;
                    });
                    console.log("Calculated plans loaded from Firestore:", calculatedPlansData.length);
                    renderCalculatedPlans();
                    saveDataToLocalStorage(); // Keep local storage in sync
                }, (error) => {
                    console.error("Error listening to calculated plans from Firestore:", error);
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for calculated plans:", error);
            }
        }

        async function saveCalculatedPlan(uid, plan) {
            if (!db) return;
            try {
                await setDoc(doc(db, `artifacts/${appId}/users/${uid}/calculatedPlans`, plan.rowId), plan);
                console.log("Calculated plan saved to Firestore:", plan.rowId);
            } catch (error) {
                console.error("Error saving calculated plan to Firestore:", error);
            }
        }

        async function deleteCalculatedPlan(uid, rowId) {
            if (!db) return;
            try {
                await deleteDoc(doc(db, `artifacts/${appId}/users/${uid}/calculatedPlans`, rowId));
                console.log("Calculated plan deleted from Firestore:", rowId);
            } catch (error) {
                console.error("Error deleting calculated plan from Firestore:", error);
            }
        }

        async function loadRunningPlans(uid) {
            if (!db) return;
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/runningPlans`));
                onSnapshot(q, (snapshot) => {
                    runningPlansData = snapshot.docs.map(doc => {
                        const data = doc.data();
                        data.assetData = getAssetData(data.symbol);
                        return data;
                    });
                    console.log("Running plans loaded from Firestore:", runningPlansData.length);
                    renderRunningPlans();
                    saveDataToLocalStorage(); // Keep local storage in sync
                }, (error) => {
                    console.error("Error listening to running plans from Firestore:", error);
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for running plans:", error);
            }
        }

        async function saveRunningPlan(uid, plan) {
            if (!db) return;
            try {
                await setDoc(doc(db, `artifacts/${appId}/users/${uid}/runningPlans`, plan.rowId), plan);
                console.log("Running plan saved to Firestore:", plan.rowId);
            } catch (error) {
                console.error("Error saving running plan to Firestore:", error);
            }
        }

        async function deleteRunningPlan(uid, rowId) {
            if (!db) return;
            try {
                await deleteDoc(doc(db, `artifacts/${appId}/users/${uid}/runningPlans`, rowId));
                console.log("Running plan deleted from Firestore:", rowId);
            } catch (error) {
                console.error("Error deleting running plan from Firestore:", error);
            }
        }

        async function loadExecutedPlans(uid) {
            if (!db) {
                console.warn("Firestore is not initialized. Cannot load executed plans.");
                loadDataFromLocalStorage();
                renderExecutedPlans();
                calculateSummaryStatistics();
                calculateAndRenderMonthlyAccumulationSummary(); // PERBAIKAN: Panggil di sini untuk fallback
                return;
            }
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/executedPlans`));
                onSnapshot(q, (snapshot) => {
                    const plans = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        data.assetData = getAssetData(data.symbol);
                        plans.push(data);
                    });
                    executedPlansData = plans.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    console.log("Executed plans loaded from Firestore:", executedPlansData.length);
                    
                    // PERBAIKAN: Panggil fungsi render utama yang akan menangani pembaruan lainnya
                    renderExecutedPlans();
                    calculateSummaryStatistics();
                    calculateAndRenderMonthlyAccumulationSummary(); // PERBAIKAN: Panggil di sini setelah data dimuat
                    
                    handleSimulatorInputChange();
                    checkTradeLimits();
                    displayLimitNotification(limitNotificationMessage);
                    
                    // Reset dan render ulang grafik saat data berubah
                    for (const sectionId in chartSections) {
                        const chartInfo = chartSections[sectionId];
                        if (chartInfo.chartInstance && chartInfo.chartInstance()) {
                            chartInfo.chartInstance().destroy();
                            chartInfo.setInstance(null);
                        }
                        chartInfo.hasRendered = false;
                    }
                    animateOnScroll();
                    saveDataToLocalStorage();
                }, (error) => {
                    console.error("Error listening to executed plans from Firestore:", error);
                    loadDataFromLocalStorage();
                    renderExecutedPlans();
                    calculateSummaryStatistics();
                    calculateAndRenderMonthlyAccumulationSummary(); // PERBAIKAN: Panggil di sini untuk fallback error
                });
            } catch (error) {
                console.error("Error setting up Firestore listener for executed plans:", error);
                loadDataFromLocalStorage();
                renderExecutedPlans();
                calculateSummaryStatistics();
                calculateAndRenderMonthlyAccumulationSummary(); // PERBAIKAN: Panggil di sini untuk fallback error
            }
        }

        async function saveExecutedPlan(uid, plan) {
            if (!db) {
                console.warn("Firestore is not initialized. Cannot save executed plan.");
                return;
            }
            try {
                await addDoc(collection(db, `artifacts/${appId}/users/${uid}/executedPlans`), plan);
                console.log("Executed plan saved to Firestore.");
            } catch (error) {
                console.error("Error saving executed plan to Firestore:", error);
            }
        }

        async function deleteAllExecutedPlans(uid) {
            if (!db) {
                console.warn("Firestore is not initialized. Cannot delete all executed plans.");
                return;
            }
            try {
                const q = query(collection(db, `artifacts/${appId}/users/${uid}/executedPlans`));
                const snapshot = await getDocs(q);
                const deletePromises = [];
                snapshot.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                await Promise.all(deletePromises);
                console.log("All executed plans deleted from Firestore.");
            } catch (error) {
                console.error("Error deleting all executed plans from Firestore:", error);
            }
        }

        // Removed loadJoinTime function as its logic is now integrated into calculateSummaryStatistics

        // --- LOCAL STORAGE FUNCTIONS (Used as fallback if Firebase is not configured or fails) ---
        function saveDataToLocalStorage() {
            try {
                localStorage.setItem('calculatedPlansData', JSON.stringify(calculatedPlansData));
                localStorage.setItem('runningPlansData', JSON.stringify(runningPlansData));
                localStorage.setItem('executedPlansData', JSON.stringify(executedPlansData));
                console.log("Data saved to localStorage.");
            }
            catch (e) { console.error("Error saving to localStorage:", e); }
        }
        function loadDataFromLocalStorage() {
            try {
                calculatedPlansData = JSON.parse(localStorage.getItem('calculatedPlansData')) || [];
                runningPlansData = JSON.parse(localStorage.getItem('runningPlansData')) || [];
                executedPlansData = JSON.parse(localStorage.getItem('executedPlansData')) || [];
                console.log("Data loaded from localStorage. Calculated Plans:", calculatedPlansData.length, "Running Plans:", runningPlansData.length, "Executed Plans:", executedPlansData.length);
            }
            catch (e) { console.error("Error loading from localStorage:", e); calculatedPlansData = []; runningPlansData = []; executedPlansData = []; }
        }

        // --- Photo Local Storage (separate for photos) ---
        function savePhotosToLocalStorage(galleryType) {
            try {
                const key = galleryType === '1:1' ? 'userPhotos' : 'userPhotos16x9';
                const data = galleryType === '1:1' ? userPhotos : userPhotos16x9;
                localStorage.setItem(key, JSON.stringify(data));
                console.log(`Photos (${galleryType}) saved to localStorage.`);
            } catch (e) {
                console.error("Error saving photos to localStorage:", e);
            }
        }

        function loadPhotosFromLocalStorage(galleryType) {
            try {
                const key = galleryType === '1:1' ? 'userPhotos' : 'userPhotos16x9';
                const data = JSON.parse(localStorage.getItem(key)) || [];
                if (galleryType === '1:1') {
                    userPhotos = data;
                } else {
                    userPhotos16x9 = data;
                }
                console.log(`Photos (${galleryType}) loaded from localStorage:`, data.length);
            } catch (e) {
                console.error("Error loading photos from localStorage:", e);
                if (galleryType === '1:1') userPhotos = [];
                else userPhotos16x9 = [];
            }
        }

        // --- Simulator Local Storage ---
        function saveSimulatorData() {
            try {
                const simData = {
                    balance: document.getElementById('simBalance').value,
                    risk: document.getElementById('simRiskPerTrade').value,
                    target: document.getElementById('simMonthlyTarget').value,
                    period: document.getElementById('simPeriod').value
                };
                localStorage.setItem('compoundingSimulatorData', JSON.stringify(simData));
            } catch(e) {
                console.error("Error saving simulator data to localStorage:", e);
            }
        }

        function loadSimulatorData() {
            try {
                const simData = JSON.parse(localStorage.getItem('compoundingSimulatorData'));
                if (simData) {
                    document.getElementById('simBalance').value = simData.balance || '';
                    document.getElementById('simRiskPerTrade').value = simData.risk || '';
                    document.getElementById('simMonthlyTarget').value = simData.target || '';
                    document.getElementById('simPeriod').value = simData.period || '';
                }
            } catch (e) {
                console.error("Error loading simulator data from localStorage:", e);
            }
        }
        
        // --- Input Rows Local Storage ---
        function saveInputRowsToLocalStorage() {
            try {
                const inputRows = document.querySelectorAll('.input-row');
                const dataToSave = [];
                inputRows.forEach(row => {
                    const rowId = row.id.split('-')[1];
                    const rowData = {
                        symbol: row.querySelector(`#symbol-${rowId}`).value,
                        tradeType: row.querySelector(`#buyBtn-${rowId}`).classList.contains('active') ? 'BUY' : 'SELL',
                        balance: row.querySelector(`#balance-${rowId}`).value,
                        riskPercent: row.querySelector(`#riskPercent-${rowId}`).value,
                        priceNow: row.querySelector(`#priceNow-${rowId}`).value,
                        openPrice: row.querySelector(`#openPrice-${rowId}`).value,
                        slPrice: row.querySelector(`#slPrice-${rowId}`).value,
                        tpPrice: row.querySelector(`#tpPrice-${rowId}`).value,
                        note: row.querySelector(`#note-${rowId}`).value,
                    };
                    dataToSave.push(rowData);
                });
                localStorage.setItem('calculatorInputRows', JSON.stringify(dataToSave));
            } catch (e) {
                console.error("Error saving input rows to localStorage:", e);
            }
        }

        function loadInputRowsFromLocalStorage() {
            try {
                const savedRows = JSON.parse(localStorage.getItem('calculatorInputRows'));
                if (savedRows && savedRows.length > 0) {
                    inputRowsContainer.innerHTML = ''; // Clear any default rows
                    savedRows.forEach(rowData => addInputRow(rowData));
                    return true; // Indicate that data was loaded
                }
                return false; // No data found
            } catch (e) {
                console.error("Error loading input rows from localStorage:", e);
                return false;
            }
        }


        // --- CHART.JS RENDERING FUNCTIONS (simplified error/loading handling) ---
        const setupChartContainer = (canvasId, loadingId, errorId, noDataId) => {
            const canvas = document.getElementById(canvasId);
            const loading = document.getElementById(loadingId);
            const error = document.getElementById(errorId);
            const noData = document.getElementById(noDataId);
            loading.classList.remove('hidden'); error.classList.add('hidden'); noData.classList.add('hidden'); canvas.style.display = 'none';
            return { canvas, loading, error, noData };
        };

        const handleChartData = (data, { canvas, loading, error, noData }, chartInstanceRef, chartType, options) => {
            loading.classList.add('hidden');
            // Check if data is empty or if all values are zero for pie chart
            if (data.labels.length === 0 || (chartType === 'pie' && data.datasets && data.datasets.length > 0 && data.datasets[0].data.every(val => val === 0))) {
                noData.classList.remove('hidden'); canvas.style.display = 'none'; return false;
            }
            canvas.style.display = 'block';
            if (chartInstanceRef.chart) chartInstanceRef.chart.destroy();
            chartInstanceRef.chart = new Chart(canvas, { type: chartType, data: { labels: data.labels, datasets: data.datasets }, options });
            return true;
        };

        async function fetchAndRenderDailyLineChart() {
            const { canvas, loading, error, noData } = setupChartContainer('dailyLineChart', 'dailyLineChartLoading', 'dailyLineChartError', 'dailyLineChartNoData');
            try {
                const now = new Date(); const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
                const tradesToday = executedPlansData.filter(trade => {
                    const tradeTimestamp = new Date(trade.timestamp).getTime();
                    return tradeTimestamp >= todayStart && tradeTimestamp <= now.getTime() && trade.outcome !== 'Cancel' && trade.outcome !== 'Tes';
                }).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                const labels = [], data = []; let currentCumulativePercentage = 0, dailyInitialBalance = null;
                tradesToday.forEach(trade => {
                    if (dailyInitialBalance === null) dailyInitialBalance = trade.balance;
                    let profitLoss = (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                    if (tradesToday.length > 0 && tradesToday[0].balance !== 0) {
                        currentCumulativePercentage = ((dailyInitialBalance + profitLoss - tradesToday[0].balance) / tradesToday[0].balance) * 100;
                        dailyInitialBalance += profitLoss;
                    } else { currentCumulativePercentage = 0; }
                    labels.push(new Date(trade.timestamp).toLocaleString('id-ID', { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }));
                    data.push(currentCumulativePercentage);
                });

                handleChartData({ labels, datasets: [{ label: 'Persentase Harian', data, borderColor: '#222', backgroundColor: 'rgba(34, 34, 34, 0.1)', fill: true, tension: 0.3, borderWidth: 1, pointRadius: 3, pointBackgroundColor: '#222', pointBorderColor: '#fff', pointHoverRadius: 5, pointHoverBackgroundColor: '#222', pointHoverBorderColor: '#fff' }] }, { canvas, loading, error, noData }, { chart: dailyLineChart, set chart(c) { dailyLineChart = c; } }, 'line', { responsive: true, maintainAspectRatio: false, animation: { duration: 1000, easing: 'easeOutQuart' }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 2) + '%' } } }, scales: { x: { title: { display: true, text: 'Tanggal & Waktu Transaksi Hari Ini', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 } } }, y: { beginAtZero: true, title: { display: true, text: 'Persentase Harian Kumulatif (%)', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => formatNumber(val, 2) + '%', color: '#555', font: { family: 'Inter', size: 7 } } } } });
            } catch (err) { console.error("Error daily line chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik harian: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderMonthlyBarChart() {
            const { canvas, loading, error, noData } = setupChartContainer('monthlyBarChart', 'monthlyBarChartLoading', 'monthlyBarChartError', 'monthlyBarChartNoData');
            try {
                executedPlansData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const monthlyStatsMap = {};
                executedPlansData.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return;
                    const monthYear = `${new Date(trade.timestamp).getFullYear()}-${(new Date(trade.timestamp).getMonth() + 1).toString().padStart(2, '0')}`;
                    if (!monthlyStatsMap[monthYear]) monthlyStatsMap[monthYear] = { initialBalance: trade.balance, currentBalance: trade.balance };
                    monthlyStatsMap[monthYear].currentBalance += (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                });
                const labels = Object.keys(monthlyStatsMap).sort();
                const data = labels.map(my => monthlyStatsMap[my].initialBalance !== 0 ? ((monthlyStatsMap[my].currentBalance - monthlyStatsMap[my].initialBalance) / monthlyStatsMap[my].initialBalance) * 100 : 0);
                const backgroundColors = data.map(val => val >= 0 ? 'rgba(34, 34, 34, 0.8)' : 'rgba(220, 53, 69, 0.8)');

                handleChartData({ labels, datasets: [{ label: 'Persentase Perubahan Bulanan', data, backgroundColor: backgroundColors, borderColor: backgroundColors.map(c => c.replace('0.8)', '1)')), borderWidth: 1 }] }, { canvas, loading, error, noData }, { chart: monthlyBarChart, set chart(c) { monthlyBarChart = c; } }, 'bar', { responsive: true, maintainAspectRatio: false, animation: { duration: 800 }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 2) + '%' } } }, scales: { x: { title: { display: true, text: 'Bulan', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 } } }, y: { beginAtZero: true, title: { display: true, text: 'Persentase (%)', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => formatNumber(val, 2) + '%', color: '#555', font: { family: 'Inter', size: 7 } } } } });
            } catch (err) { console.error("Error monthly bar chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik batang bulanan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderPieChart() {
            const { canvas, loading, error, noData } = setupChartContainer('assetSuccessPieChart', 'pieChartLoading', 'pieChartError', 'pieChartNoData');
            try {
                const takeProfitTradesByAsset = {}; let totalTakeProfitTrades = 0;
                executedPlansData.forEach(trade => { if (trade.outcome === 'Take Profit') { takeProfitTradesByAsset[trade.symbol] = (takeProfitTradesByAsset[trade.symbol] || 0) + 1; totalTakeProfitTrades++; } });

                const labels = [], data = [], backgroundColors = []; let colorIndex = 0;
                for (const symbol in takeProfitTradesByAsset) {
                    const percentage = (takeProfitTradesByAsset[symbol] / totalTakeProfitTrades) * 100;
                    labels.push(`${symbol} (${formatNumber(percentage, 2)}%)`); data.push(percentage); backgroundColors.push(getRandomColor(colorIndex++));
                }

                handleChartData({ labels, datasets: [{ data, backgroundColor: backgroundColors, hoverOffset: 10, borderColor: '#fff', borderWidth: 2 }] }, { canvas, loading, error, noData }, { chart: assetPieChart, set chart(c) { assetPieChart = c; } }, 'pie', { responsive: true, maintainAspectRatio: false, animation: { duration: 800 }, plugins: { legend: { display: true, position: 'bottom', labels: { color: '#333', font: { family: 'Inter', size: 10, weight: '300' }, padding: 15, boxWidth: 12 } }, tooltip: { callbacks: { label: ctx => `${ctx.label || ''}: ${formatNumber(ctx.raw, 2)}%` }, spacing: 10 } } });
            } catch (err) { console.error("Error pie chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik keberhasilan aset: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderOverallPercentageCumulativeChart() {
            const { canvas, loading, error, noData } = setupChartContainer('overallPercentageCumulativeChart', 'overallPercentageCumulativeChartLoading', 'overallPercentageCumulativeChartError', 'overallPercentageCumulativeChartNoData');
            try {
                const sortedTrades = [...executedPlansData].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // Actual Data
                const actualLabels = [], actualData = [];
                let initialBalance = null, currentBalance = null;
                sortedTrades.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return;
                    if (initialBalance === null) {
                        initialBalance = trade.balance;
                        currentBalance = trade.balance;
                    }
                    currentBalance += (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                    actualLabels.push(new Date(trade.timestamp).toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }));
                    actualData.push(initialBalance !== 0 ? ((currentBalance - initialBalance) / initialBalance) * 100 : 0);
                });

                // Projection Data
                const { projectionLabels, projectionData } = calculateProjectionData('percentage');
                
                // Combine data for chart
                const combinedLabels = [...actualLabels, ...projectionLabels];
                const actualDataset = {
                    label: 'Persentase Aktual',
                    data: actualData,
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    fill: true, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: '#007bff'
                };

                const projectionDataset = {
                    label: 'Proyeksi',
                    data: [...new Array(actualData.length - 1).fill(null), actualData[actualData.length - 1], ...projectionData],
                    borderColor: 'rgba(0, 123, 255, 0.5)',
                    borderDash: [5, 5],
                    fill: false, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: 'rgba(0, 123, 255, 0.5)'
                };

                const datasets = [actualDataset];
                if (projectionData.length > 0) {
                    datasets.push(projectionDataset);
                }

                handleChartData({ labels: combinedLabels, datasets }, { canvas, loading, error, noData }, { chart: overallPercentageCumulativeChart, set chart(c) { overallPercentageCumulativeChart = c; } }, 'line', { responsive: true, maintainAspectRatio: false, animation: { duration: 1000, easing: 'easeOutQuart' }, plugins: { legend: { display: true, position: 'top' }, tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 2) + '%' } } }, scales: { x: { title: { display: true, text: 'Tanggal & Waktu Trade', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 } } }, y: { beginAtZero: false, title: { display: true, text: 'Persentase Kumulatif (%)', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => formatNumber(val, 2) + '%', color: '#555', font: { family: 'Inter', size: 7 } } } } });

            } catch (err) { console.error("Error overall cumulative percentage chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik kumulatif keseluruhan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderOverallBalanceCumulativeChart() {
            const { canvas, loading, error, noData } = setupChartContainer('overallBalanceCumulativeChart', 'overallBalanceCumulativeChartLoading', 'overallBalanceCumulativeChartError', 'overallBalanceCumulativeChartNoData');
            try {
                const sortedTrades = [...executedPlansData].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                // Actual Data
                const actualLabels = [], actualData = [];
                let currentBalance = null;
                sortedTrades.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return;
                    if (currentBalance === null) currentBalance = trade.balance;
                    currentBalance += (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                    actualLabels.push(new Date(trade.timestamp).toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }));
                    actualData.push(currentBalance);
                });

                // Projection Data
                const { projectionLabels, projectionData } = calculateProjectionData('balance');

                // Combine data for chart
                const combinedLabels = [...actualLabels, ...projectionLabels];
                const actualDataset = {
                    label: 'Saldo Aktual',
                    data: actualData,
                    borderColor: '#dc3545', // PERUBAHAN: Dari hijau ke merah
                    backgroundColor: 'rgba(220, 53, 69, 0.1)', // PERUBAHAN: Dari hijau ke merah
                    fill: true, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: '#dc3545' // PERUBAHAN: Dari hijau ke merah
                };

                const projectionDataset = {
                    label: 'Proyeksi',
                    data: [...new Array(actualData.length - 1).fill(null), actualData[actualData.length - 1], ...projectionData],
                    borderColor: 'rgba(220, 53, 69, 0.5)', // PERUBAHAN: Dari hijau ke merah
                    borderDash: [5, 5],
                    fill: false, tension: 0.3, borderWidth: 1.5,
                    pointRadius: 2, pointBackgroundColor: 'rgba(220, 53, 69, 0.5)' // PERUBAHAN: Dari hijau ke merah
                };
                
                const datasets = [actualDataset];
                if (projectionData.length > 0) {
                    datasets.push(projectionDataset);
                }

                handleChartData({ labels: combinedLabels, datasets }, { canvas, loading, error, noData }, { chart: overallBalanceCumulativeChart, set chart(c) { overallBalanceCumulativeChart = c; } }, 'line', { responsive: true, maintainAspectRatio: false, animation: { duration: 1000, easing: 'easeOutQuart' }, plugins: { legend: { display: true, position: 'top' }, tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatCurrency(ctx.raw, 'USD') } } }, scales: { x: { title: { display: true, text: 'Tanggal & Waktu Trade', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 } } }, y: { beginAtZero: false, title: { display: true, text: 'Saldo Akun ($)', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => formatCurrency(val, 'USD'), color: '#555', font: { family: 'Inter', size: 7 } } } } });
            
            } catch (err) { console.error("Error overall cumulative balance chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik saldo kumulatif keseluruhan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderOverallPipsCumulativeChart() {
            const { canvas, loading, error, noData } = setupChartContainer('overallPipsCumulativeChart', 'overallPipsCumulativeChartLoading', 'overallPipsCumulativeChartError', 'overallPipsCumulativeChartNoData');
            try {
                executedPlansData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const labels = [], data = [];
                let currentCumulativePoints = 0;
                executedPlansData.forEach(trade => {
                    if (trade.outcome === 'Cancel' || trade.outcome === 'Tes') return; // Skip if cancelled or test
                    
                    let pointsForTrade = 0;
                    if (trade.outcome === 'Take Profit') {
                        // Get the visual points value for TP and use it for calculation
                        pointsForTrade = getVisualPoints(trade.tpPips).forCalc;
                    } else if (trade.outcome === 'Stop Loss') {
                        // Get the visual points value for SL and make it negative
                        pointsForTrade = -getVisualPoints(trade.slPips).forCalc;
                    }
                    currentCumulativePoints += pointsForTrade;

                    labels.push(new Date(trade.timestamp).toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }));
                    data.push(currentCumulativePoints);
                });
                handleChartData({ labels, datasets: [{ label: 'Pips/Points Kumulatif Keseluruhan', data, borderColor: '#ffc107', backgroundColor: 'rgba(255, 193, 7, 0.1)', fill: true, tension: 0.3, borderWidth: 1, pointRadius: 3, pointBackgroundColor: '#ffc107', pointBorderColor: '#fff', pointHoverRadius: 5, pointHoverBackgroundColor: '#ffc107', pointHoverBorderColor: '#fff' }] }, { canvas, loading, error, noData }, { chart: overallPipsCumulativeChart, set chart(c) { overallPipsCumulativeChart = c; } }, 'line', { responsive: true, maintainAspectRatio: false, animation: { duration: 1000, easing: 'easeOutQuart' }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + formatNumber(ctx.raw, 0) } } }, scales: { x: { title: { display: true, text: 'Tanggal & Waktu Trade', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 } } }, y: { beginAtZero: true, title: { display: true, text: 'Pips/Points', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => formatNumber(val, 0), color: '#555', font: { family: 'Inter', size: 7 } } } } });
            } catch (err) { console.error("Error overall cumulative pips chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik pips/points kumulatif keseluruhan: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        async function fetchAndRenderTradeFrequencyChart() {
            const { canvas, loading, error, noData } = setupChartContainer('tradeFrequencyChart', 'tradeFrequencyChartLoading', 'tradeFrequencyChartError', 'tradeFrequencyChartNoData');
            try {
                const tradeCounts = {};
                executedPlansData.forEach(trade => { if (trade.outcome !== 'Cancel' && trade.outcome !== 'Tes') { const key = `${trade.symbol} - ${trade.tradeType}`; tradeCounts[key] = (tradeCounts[key] || 0) + 1; } });
                const labels = Object.keys(tradeCounts).sort();
                const data = labels.map(label => tradeCounts[label]);
                const backgroundColors = labels.map(label => label.includes('BUY') ? 'rgba(34, 34, 34, 0.8)' : (label.includes('SELL') ? 'rgba(220, 53, 69, 0.8)' : 'rgba(108, 117, 125, 0.8)'));
                const borderColors = backgroundColors.map(c => c.replace('0.8)', '1)'));

                handleChartData({ labels, datasets: [{ label: 'Jumlah Eksekusi', data, backgroundColor: backgroundColors, borderColor: borderColors, borderWidth: 1 }] }, { canvas, loading, error, noData }, { chart: tradeFrequencyChart, set chart(c) { tradeFrequencyChart = c; } }, 'bar', { responsive: true, maintainAspectRatio: false, animation: { duration: 800 }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => `${ctx.label}: ${ctx.raw} kali` } } }, scales: { x: { title: { display: true, text: 'Aset & Tipe Trade', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { color: '#555', font: { family: 'Inter', size: 7 }, autoSkip: false, maxRotation: 45, minRotation: 45 } }, y: { beginAtZero: true, title: { display: true, text: 'Jumlah Eksekusi', color: '#555', font: { family: 'Inter', size: 8, weight: 'bold' } }, ticks: { callback: val => Number.isInteger(val) ? val : null, color: '#555', font: { family: 'Inter', size: 7 } } } } });
            } catch (err) { console.error("Error trade frequency chart:", err); loading.classList.add('hidden'); error.textContent = 'Gagal memuat data grafik frekuensi trade: ' + err.message; error.classList.remove('hidden'); canvas.style.display = 'none'; }
        }

        // --- NEW: Compounding Simulator Logic ---
        function calculateProjectionData(dataType) {
            const simBalanceInput = document.getElementById('simBalance');
            const simMonthlyTargetInput = document.getElementById('simMonthlyTarget');
            const simPeriodInput = document.getElementById('simPeriod');

            const startBalance = parseFloat(simBalanceInput.value);
            const monthlyTarget = parseFloat(simMonthlyTargetInput.value) / 100;
            const periodMonths = parseInt(simPeriodInput.value);

            const projectionLabels = [];
            const projectionData = [];

            if (isNaN(startBalance) || isNaN(monthlyTarget) || isNaN(periodMonths) || periodMonths <= 0) {
                return { projectionLabels, projectionData };
            }

            const sortedTrades = [...executedPlansData].filter(t => t.outcome !== 'Cancel' && t.outcome !== 'Tes').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            let lastTradeDate = sortedTrades.length > 0 ? new Date(sortedTrades[sortedTrades.length - 1].timestamp) : new Date();
            let currentProjectedBalance = startBalance;
            let historicalInitialBalance = sortedTrades.length > 0 ? sortedTrades[0].balance : startBalance;

            for (let i = 1; i <= periodMonths; i++) {
                currentProjectedBalance *= (1 + monthlyTarget);
                const projectedDate = new Date(lastTradeDate);
                projectedDate.setMonth(projectedDate.getMonth() + i);
                
                projectionLabels.push(projectedDate.toLocaleString('id-ID', { day: 'numeric', month: 'short', year: 'numeric' }));
                
                if (dataType === 'balance') {
                    projectionData.push(currentProjectedBalance);
                } else if (dataType === 'percentage') {
                    const percentageChange = historicalInitialBalance > 0 ? ((currentProjectedBalance - historicalInitialBalance) / historicalInitialBalance) * 100 : 0;
                    projectionData.push(percentageChange);
                }
            }
            return { projectionLabels, projectionData };
        }
        
        function handleSimulatorInputChange() {
            // Save data to local storage whenever it changes
            saveSimulatorData();
            // This function triggers the re-rendering of the charts that need projection lines.
            // The chart rendering functions themselves will read the simulator inputs.
            if (chartSections.overallBalanceCumulativeStatisticsSection.hasRendered) {
                fetchAndRenderOverallBalanceCumulativeChart();
            }
            if (chartSections.overallPercentageCumulativeStatisticsSection.hasRendered) {
                fetchAndRenderOverallPercentageCumulativeChart();
            }
        }


        // --- MONTHLY ACCUMULATION SUMMARY FUNCTION (FIXED) ---
        function calculateAndRenderMonthlyAccumulationSummary() {
            const summaryBody = document.getElementById('monthlySummaryTableBody');
            if (!summaryBody) return;

            const relevantTrades = executedPlansData.filter(trade => trade.outcome !== 'Cancel' && trade.outcome !== 'Tes').sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (relevantTrades.length === 0) {
                summaryBody.innerHTML = `<tr><td colspan="4" class="py-4 text-center text-gray-500">Belum ada data untuk ditampilkan.</td></tr>`;
                return;
            }

            // Group trades by month key (YYYY-MM)
            const monthlyData = {};
            relevantTrades.forEach(trade => {
                const tradeDate = new Date(trade.timestamp);
                const monthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth()).padStart(2, '0')}`; // Use 0-indexed month
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = [];
                }
                monthlyData[monthKey].push(trade);
            });

            summaryBody.innerHTML = ''; // Clear previous content

            const firstTradeDate = new Date(relevantTrades[0].timestamp);
            const lastTradeDate = new Date(relevantTrades[relevantTrades.length - 1].timestamp);

            let currentDate = new Date(firstTradeDate.getFullYear(), firstTradeDate.getMonth(), 1);
            let lastMonthBalance = relevantTrades[0].balance; // Start with the balance of the very first trade

            // Loop through each month from the first trade to the last trade
            while (currentDate <= lastTradeDate) {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const monthKey = `${year}-${String(month).padStart(2, '0')}`;
                const monthName = currentDate.toLocaleString('id-ID', { month: 'long', year: 'numeric' });

                const tradesInMonth = monthlyData[monthKey] || [];
                
                let totalProfitLossInMonth = 0;
                tradesInMonth.forEach(trade => {
                    totalProfitLossInMonth += (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                });
                
                const finalBalanceInMonth = lastMonthBalance + totalProfitLossInMonth;
                const percentageChange = lastMonthBalance > 0 ? (totalProfitLossInMonth / lastMonthBalance) * 100 : 0;
                const tradeCount = tradesInMonth.length;
                
                const percentageClass = percentageChange > 0 ? 'positive-value' : (percentageChange < 0 ? 'negative-value' : 'neutral-value');
                
                const row = `
                    <tr>
                        <td class="py-3 px-4 text-center text-neutral-value">${monthName}</td>
                        <td class="py-3 px-4 text-center ${percentageClass}">${formatNumber(percentageChange, 2)}%</td>
                        <td class="py-3 px-4 text-center text-neutral-value">${tradeCount}</td>
                        <td class="py-3 px-4 text-center text-neutral-value">${formatCurrency(finalBalanceInMonth, 'USD')}</td>
                    </tr>
                `;
                summaryBody.insertAdjacentHTML('beforeend', row);

                // Update the balance for the next iteration
                lastMonthBalance = finalBalanceInMonth;

                // Move to the next month
                currentDate.setMonth(currentDate.getMonth() + 1);
            }
        }

        // --- CORE CALCULATOR LOGIC ---
        const getAssetData = (symbol) => assetValues[symbol] || { decimals: 5, pipValue: 10.00, contractSize: 100000, type: 'forexMajor', currency: 'USD', minLotIncrement: 0.01, pipsDecimals: 1 };

        // Updated calculatePipsPoints to correctly handle different asset types
        function calculatePipsPoints(priceDiff, symbol) {
            const assetData = getAssetData(symbol);
            if (!assetData) return 0; // Handle unknown symbol

            if (assetData.type.includes('forex')) {
                // For 5-decimal forex pairs (e.g., EUR/USD), 1 pip = 0.0001 (multiplier 10000)
                // For 3-decimal forex pairs (e.g., USD/JPY), 1 pip = 0.01 (multiplier 100)
                const pipMultiplier = (assetData.decimals === 5) ? 10000 : 100;
                return priceDiff * pipMultiplier;
            }
            // For other assets (indices, commodities, crypto), priceDiff is directly the "points"
            return priceDiff;
        }

        function calculateRow(rowId) {
            const rowElement = document.getElementById(`inputRow-${rowId}`); if (!rowElement) return null;
            const tradeType = rowElement.querySelector(`#buyBtn-${rowId}`).classList.contains('active') ? 'BUY' : (rowElement.querySelector(`#sellBtn-${rowId}`).classList.contains('active') ? 'SELL' : null);
            const inputs = ['symbol', 'balance', 'riskPercent', 'priceNow', 'openPrice', 'slPrice', 'tpPrice', 'note'].reduce((acc, id) => ({ ...acc, [id]: rowElement.querySelector(`#${id}-${rowCounter}`) }), {});
            
            // Get values directly from input elements
            const selectedSymbol = inputs.symbol.value;
            const balance = parseFloat(inputs.balance.value);
            const riskPercent = parseFloat(inputs.riskPercent.value);
            const priceNow = parseFloat(inputs.priceNow.value);
            const openPrice = parseFloat(inputs.openPrice.value);
            const slPrice = parseFloat(inputs.slPrice.value);
            const tpPrice = parseFloat(inputs.tpPrice.value);
            const note = inputs.note.value.trim();

            const riskLimitNote = rowElement.querySelector(`#riskLimitNote-${rowId}`);
            let isValid = true;
            
            // Clear previous messages and error highlights
            riskLimitNote.classList.add('hidden');
            Object.values(inputs).forEach(input => input.classList.remove('border-red-500'));

            // Validate inputs
            if (!selectedSymbol || selectedSymbol.trim() === '') { inputs.symbol.classList.add('border-red-500'); isValid = false; }
            if (!tradeType) isValid = false;
            if (isNaN(balance) || balance <= 0) { inputs.balance.classList.add('border-red-500'); isValid = false; }
            if (isNaN(riskPercent) || riskPercent <= 0) { inputs.riskPercent.classList.add('border-red-500'); isValid = false; }
            if (isNaN(priceNow) || priceNow < 0) { inputs.priceNow.classList.add('border-red-500'); isValid = false; }
            if (isNaN(openPrice) || openPrice < 0) { inputs.openPrice.classList.add('border-red-500'); isValid = false; }
            if (isNaN(slPrice) || slPrice < 0) { inputs.slPrice.classList.add('border-red-500'); isValid = false; }
            if (isNaN(tpPrice) || tpPrice < 0) { inputs.tpPrice.classList.add('border-red-500'); isValid = false; }

            const cappedRiskPercent = riskPercent > MAX_RISK_PER_TRADE ? MAX_RISK_PER_TRADE : riskPercent;
            if (riskPercent > MAX_RISK_PER_TRADE) { riskLimitNote.textContent = `Risiko maksimal adalah ${MAX_RISK_PER_TRADE}%`; riskLimitNote.classList.remove('hidden'); isValid = false; }

            if (!isValid) return { error: true }; // Return early if basic validation fails

            const assetData = getAssetData(selectedSymbol);
            const { pipValue: pipPointValuePerStandardLot, minLotIncrement } = assetData;

            const [priceDiffSL, priceDiffTP, priceDiffPending] = tradeType === 'BUY' ? [openPrice - slPrice, tpPrice - openPrice, priceNow - openPrice] : [slPrice - openPrice, openPrice - tpPrice, openPrice - priceNow];
            
            // --- START OF FIX: Use visual points for calculation ---
            const slPipsPrecise = calculatePipsPoints(priceDiffSL, selectedSymbol);
            const tpPipsPrecise = calculatePipsPoints(priceDiffTP, selectedSymbol);
            const pendingPipsPrecise = calculatePipsPoints(priceDiffPending, selectedSymbol);

            // Get the visual points value which will be used for all financial calculations
            const slPointsForCalc = getVisualPoints(slPipsPrecise).forCalc;
            const tpPointsForCalc = getVisualPoints(tpPipsPrecise).forCalc;
            // --- END OF FIX ---

            const riskAmount = balance * (cappedRiskPercent / 100);
            
            // Calculate lot size based on the visual/adjusted points value
            let calculatedLotSize = (slPointsForCalc > 0 && pipPointValuePerStandardLot > 0) ?
                                    Math.floor((riskAmount / (slPointsForCalc * pipPointValuePerStandardLot)) / minLotIncrement) * minLotIncrement :
                                    0;

            let finalLotSize = calculatedLotSize;
            let finalNettSL, finalNettTP;

            if (calculatedLotSize === 0 && riskAmount > 0 && slPointsForCalc > 0 && pipPointValuePerStandardLot > 0) {
                finalLotSize = minLotIncrement;
            }

            // Calculate final profit/loss based on the visual/adjusted points and final lot size
            finalNettSL = -(finalLotSize * slPointsForCalc * pipPointValuePerStandardLot);
            finalNettTP = (finalLotSize * tpPointsForCalc * pipPointValuePerStandardLot);
            
            const actualRiskPercent = (balance > 0) ? (Math.abs(finalNettSL) / balance) * 100 : 0;
            const rrPips = slPointsForCalc > 0 ? tpPointsForCalc / slPointsForCalc : 0;
            const [percentageSL, percentageTP] = balance > 0 ? [(Math.abs(finalNettSL) / balance) * 100, (finalNettTP / balance) * 100] : [0, 0];

            return {
                rowId, symbol: selectedSymbol, tradeType, balance, entryTime: new Date().toISOString(),
                openPrice, slPrice, tpPrice, priceNow,
                pendingPips: pendingPipsPrecise, // Store precise value
                slPips: slPipsPrecise,           // Store precise value
                tpPips: tpPipsPrecise,           // Store precise value
                rrPips, rrPercentage: { sl: percentageSL, tp: percentageTP },
                lotSize: finalLotSize, nettSL: finalNettSL, nettTP: finalNettTP,
                error: false, assetData, riskPercent: actualRiskPercent, note
            };
        }

        function displayCalculationDetails(result) {
            calculationDetailsContainer.innerHTML = '';
            // This section is now hidden by default and might be used for single-plan details if needed in the future
            // For now, it won't display anything unless explicitly made visible and populated.
        }

        function calculateAllRows() {
            console.log("Calculating all rows...");
            calculatedPlansData = []; // Clear previous calculated plans
            const allInputRows = document.querySelectorAll('.input-row');
            if (allInputRows.length === 0) {
                renderCalculatedPlans(); // Render empty table
                return;
            }
            allInputRows.forEach(row => {
                const rowId = row.id.split('-')[1];
                const result = calculateRow(rowId);
                if (result && !result.error) { // Check for error flag
                    calculatedPlansData.push(result);
                    if (db && userId !== 'anonymous') {
                        saveCalculatedPlan(userId, result);
                    }
                }
            });
            renderCalculatedPlans();
            saveDataToLocalStorage();
            console.log("Calculation complete. Calculated Plans:", calculatedPlansData.length);
        }

        function renderPlans(plans, bodyElement, colspan, emptyMessage, isCalculated = false, isRunning = false) {
            bodyElement.innerHTML = '';
            if (plans.length === 0) {
                bodyElement.innerHTML = `<tr><td colspan="${colspan}" class="py-4 text-center text-gray-500">${emptyMessage}</td></tr>`;
                return;
            }

            plans.forEach(plan => {
                const { symbol, tradeType, balance, entryTime, openPrice, slPrice, tpPrice, pendingPips, slPips, tpPips, rrPips, rrPercentage, lotSize, nettSL, nettTP, note, assetData, outcome, timestamp, rowId } = plan;
                const currentAssetData = assetData || getAssetData(symbol);

                // --- START OF FIX: Use getVisualPoints for display ---
                const slPipsDisplay = getVisualPoints(slPips).display;
                const tpPipsDisplay = getVisualPoints(tpPips).display;
                const pendingPipsDisplay = getVisualPoints(pendingPips).display;
                // --- END OF FIX ---

                const slPipsClass = parseFloat(slPipsDisplay) === 0 ? 'negative-value' : 'neutral-value';
                const tpPipsClass = parseFloat(tpPipsDisplay) > 0 ? 'positive-value' : 'negative-value';
                const pendingPipsClass = parseFloat(pendingPipsDisplay) >= 0 ? 'positive-value' : 'negative-value';
                const lotSizeClass = parseFloat(lotSize) === 0 ? 'negative-value' : 'neutral-value';
                const nettSLClass = 'negative-value';
                const nettTPClass = nettTP >= 0 ? 'positive-value' : 'negative-value';
                const rrPipsFormatted = rrPips > 0 ? '1:' + formatNumber(rrPips, 1, false) : 'N/A';
                const rrPipsClass = rrPips > 0 ? 'positive-value' : 'neutral-value';
                const rrPercentageClass = (rrPercentage && rrPercentage.tp >= 0) ? 'positive-value' : 'negative-value';

                const entryTimeFormatted = new Date(entryTime).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const exitTimeFormatted = timestamp ? new Date(timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : 'N/A';
                const outcomeText = outcome === 'Cancel' ? 'Dibatalkan' : 
                                    outcome === 'Tes' ? 'Tes Selesai' :
                                    (outcome === 'Stop Loss' ? 'Selesai: Stop Loss' : 
                                    (outcome === 'Take Profit' ? 'Selesai: Take Profit' : 'Running'));

                let actionButtonsHtml = '';
                if (isCalculated) {
                    actionButtonsHtml = `<button type="button" class="action-button-small" data-from-section="calculated" data-outcome="Running" data-row-id="${rowId}">Set Running</button>`;
                } else if (isRunning) {
                    actionButtonsHtml = `
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Tes" data-row-id="${rowId}">TES</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Cancel" data-row-id="${rowId}">BATAL</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Stop Loss" data-row-id="${rowId}">STOP LOSS</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Take Profit" data-row-id="${rowId}">TAKE PROFIT</button>
                        <button type="button" class="action-button-small" data-from-section="running" data-outcome="Edit" data-row-id="${rowId}">EDIT</button>
                    `;
                }

                bodyElement.insertAdjacentHTML('beforeend', `
                    <tr class="hover:bg-gray-50">
                        <td class="py-3 px-4 text-neutral-value">${symbol || 'N/A'}</td><td class="py-3 px-4 font-semibold ${tradeType === 'BUY' ? 'positive-value' : 'negative-value'}">${tradeType || 'N/A'}</td>
                        <td class="py-3 px-4 text-neutral-value">${formatCurrency(balance, 'USD')}</td><td class="py-3 px-4 text-neutral-value">${entryTimeFormatted}</td>
                        <td class="py-3 px-4 text-neutral-value">${formatNumber(openPrice, currentAssetData.decimals, false)}</td><td class="py-3 px-4 text-neutral-value">${formatNumber(slPrice, currentAssetData.decimals, false)}</td>
                        <td class="py-3 px-4 text-neutral-value">${formatNumber(tpPrice, currentAssetData.decimals, false)}</td>
                        <td class="py-3 px-4 ${pendingPipsClass}">${pendingPipsDisplay}</td>
                        <td class="py-3 px-4 ${slPipsClass}">${slPipsDisplay}</td>
                        <td class="py-3 px-4 ${tpPipsClass}">${tpPipsDisplay}</td>
                        <td class="py-3 px-4 ${rrPipsClass}">${rrPipsFormatted}</td><td class="py-3 px-4 ${rrPercentageClass}">${formatNumber(rrPercentage ? rrPercentage.sl : 0, 2)}% : ${formatNumber(rrPercentage ? rrPercentage.tp : 0, 2)}%</td>
                        <td class="py-3 px-4 ${lotSizeClass}">${formatNumber(lotSize, 2)}</td><td class="py-3 px-4 ${nettSLClass}">${formatCurrency(nettSL, 'USD')}</td>
                        <td class="py-3 px-4 ${nettTPClass}">${formatCurrency(nettTP, 'USD')}</td><td class="py-3 px-4 text-neutral-value">${note || '-'}</td>
                        ${(isCalculated || isRunning) ? `<td class="py-3 px-4 text-center action-buttons-cell">${actionButtonsHtml}</td>` : `<td class="py-3 px-4 text-center"><span>${outcomeText}</span></td><td class="py-3 px-4 text-neutral-value">${exitTimeFormatted}</td>`}
                    </tr>
                `);
            });

            // Attach event listeners after all rows are added
            bodyElement.querySelectorAll('.action-button-small').forEach(button => {
                button.addEventListener('click', (event) => {
                    const { rowId, outcome, fromSection } = event.target.dataset;
                    if (fromSection === 'calculated') {
                        setRunning(rowId);
                    } else if (fromSection === 'running') {
                        if (outcome === 'Edit') {
                            editRunningPlan(rowId);
                        } else {
                            completeTrade(rowId, outcome, fromSection);
                        }
                    }
                });
            });
        }

        function renderCalculatedPlans() {
            console.log("Rendering calculated plans. Data length:", calculatedPlansData.length);
            renderPlans(calculatedPlansData, calculatedPlansBody, 17, 'Belum ada rencana trading baru.', true, false); // Pass true for isCalculated
        }

        function renderRunningPlans() {
            console.log("Rendering running plans. Data length:", runningPlansData.length);
            renderPlans(runningPlansData, runningPlansBody, 17, 'Belum ada rencana trading aktif.', false, true); // Pass true for isRunning
        }

        async function renderExecutedPlans() {
            console.log("Rendering executed plans. Data length:", executedPlansData.length);
            renderPlans(executedPlansData, executedPlansBody, 18, 'Belum ada rencana trading yang selesai.');
            updateRiskRewardStatistics();
        }

        async function completeTrade(rowId, outcome, fromSection) {
            console.log(`Completing trade for rowId: ${rowId} with outcome: ${outcome} from section: ${fromSection}`);
            let planToExecute;
            if (fromSection === 'calculated') {
                const index = calculatedPlansData.findIndex(plan => plan.rowId === rowId);
                if (index !== -1) {
                    planToExecute = calculatedPlansData.splice(index, 1)[0];
                    if (db && userId !== 'anonymous') {
                        await deleteCalculatedPlan(userId, rowId);
                    }
                }
            } else if (fromSection === 'running') {
                const index = runningPlansData.findIndex(plan => plan.rowId === rowId);
                if (index !== -1) {
                    planToExecute = runningPlansData.splice(index, 1)[0];
                    if (db && userId !== 'anonymous') {
                        await deleteRunningPlan(userId, rowId);
                    }
                }
            }

            if (planToExecute) {
                planToExecute.outcome = outcome;
                planToExecute.timestamp = new Date().toISOString();
                
                if (outcome === 'Tes') {
                    planToExecute.note = 'Tes selesai silahkan chek di bagian Ringkasan Bulanan (Akumulasi).';
                }

                executedPlansData.push(planToExecute);
                
                if (db && userId !== 'anonymous') {
                    await saveExecutedPlan(userId, planToExecute);
                } else {
                    saveDataToLocalStorage(); // Fallback to local storage
                }

                renderCalculatedPlans(); // Re-render calculated plans
                renderRunningPlans();   // Re-render running plans
                renderExecutedPlans();  // Re-render executed plans
                
                // Explicitly call summary and risk/reward updates
                calculateSummaryStatistics();
                updateRiskRewardStatistics();
                calculateAndRenderMonthlyAccumulationSummary();
                handleSimulatorInputChange(); // NEW: Update charts with projection
                checkTradeLimits();
                displayLimitNotification(limitNotificationMessage);

                // Destroy and reset chart rendering flags
                for (const sectionId in chartSections) {
                    const chartInfo = chartSections[sectionId];
                    if (chartInfo.chartInstance && chartInfo.chartInstance()) { chartInfo.chartInstance().destroy(); chartInfo.setInstance(null); chartInfo.hasRendered = false; }
                }
                console.log("Trade completed and data updated.");
            } else { console.warn(`Trade dengan rowId ${rowId} tidak ditemukan di rencana ${fromSection}.`); }
        }

        async function setRunning(rowId) {
            console.log(`Setting trade for rowId: ${rowId} to Running`);
            const index = calculatedPlansData.findIndex(plan => plan.rowId === rowId);
            if (index !== -1) {
                const planToRun = calculatedPlansData.splice(index, 1)[0];
                planToRun.status = 'Running'; // Add a status property
                runningPlansData.push(planToRun);

                if (db && userId !== 'anonymous') {
                    await deleteCalculatedPlan(userId, rowId);
                    await saveRunningPlan(userId, planToRun);
                } else {
                    saveDataToLocalStorage();
                }
                renderCalculatedPlans();
                renderRunningPlans();
                console.log("Trade moved to Running plans.");
            } else {
                console.warn(`Trade dengan rowId ${rowId} tidak ditemukan di rencana yang dihitung.`);
            }
        }

        async function editRunningPlan(rowId) {
            console.log(`Mengedit trade yang berjalan untuk rowId: ${rowId}`);
            const index = runningPlansData.findIndex(plan => plan.rowId === rowId);
            if (index !== -1) {
                const planToEdit = runningPlansData.splice(index, 1)[0]; // Hapus dari rencana yang berjalan
                if (db && userId !== 'anonymous') {
                    await deleteRunningPlan(userId, rowId);
                } else {
                    saveDataToLocalStorage();
                }

                // Tambahkan baris input baru dan isi dengan data dari rencana yang akan diedit
                addInputRow(planToEdit); // Lewati data rencana untuk mengisi formulir sebelumnya

                renderRunningPlans(); // Render ulang rencana yang berjalan untuk mencerminkan penghapusan
                console.log("Trade dipindahkan dari rencana Berjalan ke formulir input untuk diedit.");
            }
        }

        // --- DYNAMIC INPUT ROW MANAGEMENT ---
        function addInputRow(initialData = {}) {
            rowCounter++; const newRowId = `inputRow-${rowCounter}`;
            const groupedAssets = { 'Forex Mayor': [], 'Forex Cross Rate': [], 'Forex Eksotis': [], 'Komoditas': [], 'Indeks': [], 'Kripto': [] };
            Object.keys(assetValues).forEach(symbol => {
                const asset = assetValues[symbol]; let categoryLabel;
                switch (asset.type) {
                    case 'forexMajor': categoryLabel = 'Forex Mayor'; break; case 'forexCross': categoryLabel = 'Forex Cross Rate'; break;
                    case 'forexExotic': categoryLabel = 'Forex Eksotis'; break; case 'commodity': categoryLabel = 'Komoditas'; break;
                    case 'index': categoryLabel = 'Indeks'; break; case 'crypto': categoryLabel = 'Kripto'; break; default: categoryLabel = 'Lainnya';
                }
                if (!groupedAssets[categoryLabel]) groupedAssets[categoryLabel] = [];
                groupedAssets[categoryLabel].push(symbol);
            });
            let symbolsOptions = '<option value="" disabled selected>Pilih Aset</option>'; // Added default option
            const categoryOrder = ['Forex Mayor', 'Forex Cross Rate', 'Forex Eksotis', 'Komoditas', 'Indeks', 'Kripto', 'Lainnya'];
            categoryOrder.forEach(category => {
                if (groupedAssets[category] && groupedAssets[category].length > 0) {
                    symbolsOptions += `<optgroup label="${category}">`;
                    groupedAssets[category].sort().forEach(symbol => { symbolsOptions += `<option value="${symbol}">${symbol}</option>`; });
                    symbolsOptions += `</optgroup>`;
                }
            });
const rowHtml = `
                <div id="${newRowId}" class="input-row bg-white p-6 rounded-lg border border-gray-200 relative">
                    <button type="button" class="delete-row-btn absolute top-3 right-3"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-y-4 gap-x-6">
                        <div><label for="symbol-${rowCounter}" class="block text-sm input-label mb-1">Aset</label><select id="symbol-${rowCounter}" name="symbol" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-gray-300 focus:border-gray-300 sm:text-sm select-field">${symbolsOptions}</select></div>
                        <div><label for="tradeType-${rowCounter}" class="block text-sm input-label mb-1">Tipe Trade</label><div class="flex rounded-md shadow-sm"><button type="button" id="buyBtn-${rowCounter}" class="buy-button w-1/2 py-2 px-4 rounded-l-md border text-center font-medium">BUY</button><button type="button" id="sellBtn-${rowCounter}" class="sell-button w-1/2 py-2 px-4 rounded-r-md border text-center font-medium">SELL</button></div></div>
                        <div><label for="balance-${rowCounter}" class="block text-sm input-label mb-1">Balance Akun ($)</label><input type="number" id="balance-${rowCounter}" name="balance" step="0.01" value="${initialData.balance !== undefined ? initialData.balance : ''}" placeholder="Cth: 10000" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div class="input-group-percent"><label for="riskPercent-${rowCounter}" class="block text-sm input-label mb-1">Risiko (%)</label><div class="flex mt-1"><input type="number" id="riskPercent-${rowCounter}" name="riskPercent" step="0.01" value="${initialData.riskPercent !== undefined ? initialData.riskPercent : ''}" placeholder="Cth: 0.2" class="block w-full border rounded-l-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"><span class="inline-flex items-center px-3 border border-l-0 rounded-r-md text-sm font-medium"> % </span></div><p id="riskLimitNote-${rowCounter}" class="text-red-500 text-xs mt-1 hidden">Risiko maksimal adalah ${MAX_RISK_PER_TRADE}%</p></div>
                        <div><label for="priceNow-${rowCounter}" class="block text-sm input-label mb-1">Price Now</label><input type="number" id="priceNow-${rowCounter}" name="priceNow" step="any" value="${initialData.priceNow !== undefined ? initialData.priceNow : ''}" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div><label for="openPrice-${rowCounter}" class="block text-sm input-label mb-1">Open Price</label><input type="number" id="openPrice-${rowCounter}" name="openPrice" step="any" value="${initialData.openPrice !== undefined ? initialData.openPrice : ''}" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field">
                        </div>
                        <div><label for="slPrice-${rowCounter}" class="block text-sm input-label mb-1">SL Price</label><input type="number" id="slPrice-${rowCounter}" name="slPrice" step="any" value="${initialData.slPrice !== undefined ? initialData.slPrice : ''}" placeholder="Cth: 1.07000 / 34900.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div><label for="tpPrice-${rowCounter}" class="block text-sm input-label mb-1">TP Price</label><input type="number" id="tpPrice-${rowCounter}" name="tpPrice" step="any" value="${initialData.tpPrice !== undefined ? initialData.tpPrice : ''}" placeholder="Cth: 1.09000 / 35500.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                        <div><label for="note-${rowCounter}" class="block text-sm input-label mb-1">Catatan (Opsional)</label><input type="text" id="note-${rowCounter}" name="note" value="${initialData.note !== undefined ? initialData.note : ''}" placeholder="Cth: Breakout strategy" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                    </div>
                </div>
            `;
            inputRowsContainer.insertAdjacentHTML('beforeend', rowHtml);
            
            // Attach event listeners to all inputs in the new row to save data automatically
            const newRowElement = document.getElementById(newRowId);
            newRowElement.querySelectorAll('input, select').forEach(input => {
                input.addEventListener('change', saveInputRowsToLocalStorage);
            });
            const buyBtn = newRowElement.querySelector(`#buyBtn-${rowCounter}`);
            const sellBtn = newRowElement.querySelector(`#sellBtn-${rowCounter}`);
            
            buyBtn.addEventListener('click', () => {
                buyBtn.classList.add('active');
                sellBtn.classList.remove('active');
                saveInputRowsToLocalStorage();
            });
            sellBtn.addEventListener('click', () => {
                sellBtn.classList.add('active');
                buyBtn.classList.remove('active');
                saveInputRowsToLocalStorage();
            });

            newRowElement.querySelector('.delete-row-btn').addEventListener('click', () => {
                newRowElement.remove();
                saveInputRowsToLocalStorage();
            });


            const symbolSelect = document.getElementById(`symbol-${rowCounter}`);
            const priceNowInput = document.getElementById(`priceNow-${rowCounter}`);
            const openPriceInput = document.getElementById(`openPrice-${rowCounter}`);
            const slPriceInput = document.getElementById(`slPrice-${rowCounter}`);
            const tpPriceInput = document.getElementById(`tpPrice-${rowCounter}`);

            const updatePriceInputStepsAndFormat = (selectedSymbol) => {
                const assetData = getAssetData(selectedSymbol);
                const decimals = assetData ? assetData.decimals : 5;
                const stepValue = getStepValue(decimals);

                [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(input => {
                    if (input) { // Add null check here
                        input.setAttribute('step', stepValue);
                        if (input.value !== '') {
                            // Only format the value if it's not empty, to avoid changing user's partial input
                            input.value = parseFloat(input.value).toFixed(decimals);
                        }
                    }
                });
            };

            if (symbolSelect) { // Add null check here
                symbolSelect.addEventListener('change', (event) => {
                    updatePriceInputStepsAndFormat(event.target.value);
                });
            }

            // Apply formatting on blur for price inputs
            [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(input => {
                if (input) { // Add null check here
                    input.addEventListener('blur', (event) => {
                        if (symbolSelect && event.target.value !== '') { // Add null check and empty string check
                            const assetData = getAssetData(symbolSelect.value);
                            const decimals = assetData ? assetData.decimals : 5;
                            event.target.value = parseFloat(event.target.value).toFixed(decimals);
                        }
                    });
                }
            });

            if (initialData.tradeType === 'BUY') { if (buyBtn) buyBtn.classList.add('active'); if (sellBtn) sellBtn.classList.remove('active'); }
            else if (initialData.tradeType === 'SELL') { if (sellBtn) sellBtn.classList.add('active'); if (buyBtn) buyBtn.classList.remove('active'); }
            else { if (buyBtn) buyBtn.classList.add('active'); if (sellBtn) sellBtn.classList.remove('active'); }
            
            if (initialData.symbol && symbolSelect) { // Add null check here
                symbolSelect.value = initialData.symbol;
                // Pastikan pemformatan awal dan pengaturan langkah untuk data yang dimuat
                updatePriceInputStepsAndFormat(initialData.symbol);
            }

            const riskPercentInput = document.getElementById(`riskPercent-${rowCounter}`); const riskLimitNote = document.getElementById(`riskLimitNote-${rowCounter}`);
            if (riskPercentInput) { // Add null check here
                riskPercentInput.addEventListener('input', () => {
                    let value = parseFloat(riskPercentInput.value);
                    if (isNaN(value)) { if (riskLimitNote) riskLimitNote.classList.add('hidden'); return; }
                    if (value > MAX_RISK_PER_TRADE) { riskPercentInput.value = MAX_RISK_PER_TRADE; if (riskLimitNote) riskLimitNote.classList.remove('hidden'); } else { if (riskLimitNote) riskLimitNote.classList.add('hidden'); }
                });
            }
            if (newRowElement) { // Add null check here
                newRowElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            console.log("Baris input ditambahkan:", newRowId);
        }

        // --- EXPORT FUNCTIONS (REVISED) ---
        /**
         * Converts an array of objects to a CSV string and triggers a download.
         * @param {string} filename The name of the file to download (e.g., "data.csv").
         * @param {Array<Object>} dataArray The array of data objects to export.
         * @param {Array<string>} headers An array of strings for the CSV header row.
         */
        function downloadAsExcel(filename, dataArray, headers) {
            if (!dataArray || dataArray.length === 0) {
                showMessageBox('Informasi', 'Tidak ada data untuk diunduh.', false);
                return;
            }

            // Create CSV content from headers
            let csvContent = headers.join(',') + '\r\n';

            // Create CSV content from data
            dataArray.forEach(row => {
                const rowData = headers.map(header => {
                    // Find the key in the row object that corresponds to the header
                    // This is a bit naive, assumes header matches key after lowercasing and removing spaces
                    const key = Object.keys(row).find(k => k.toLowerCase().replace(/_/g, '') === header.toLowerCase().replace(/ /g, ''));
                    let value = row[key] !== undefined && row[key] !== null ? row[key] : '';

                    // Sanitize value for CSV: escape quotes and handle commas
                    if (typeof value === 'string') {
                        value = `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csvContent += rowData.join(',') + '\r\n';
            });

            // Create a data URI and trigger the download
            const encodedUri = encodeURI("data:text/csv;charset=utf-8," + csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link); // Required for Firefox
            link.click();
            document.body.removeChild(link);
        }

        /**
         * Prepares a standardized data object for export from a plan object.
         * @param {Object} plan The plan object (from calculated, running, or executed data).
         * @param {string} status The status of the plan (e.g., "Baru", "Aktif", "Selesai").
         * @returns {Object} A standardized object for CSV export.
         */
        function preparePlanForExport(plan, status) {
             const currentAssetData = plan.assetData || getAssetData(plan.symbol);
            return {
                "Status": status,
                "Aset": plan.symbol || 'N/A',
                "Trade": plan.tradeType,
                "BalanceAkun": plan.balance,
                "WaktuMasuk": new Date(plan.entryTime).toLocaleString('id-ID'),
                "OpenPrice": formatNumber(plan.openPrice, currentAssetData.decimals, false),
                "SLPrice": formatNumber(plan.slPrice, currentAssetData.decimals, false),
                "TPPrice": formatNumber(plan.tpPrice, currentAssetData.decimals, false),
                "PendingPipsPoints": getVisualPoints(plan.pendingPips).display,
                "SLPipsPoints": getVisualPoints(plan.slPips).display,
                "TPPipsPoints": getVisualPoints(plan.tpPips).display,
                "RRPips": plan.rrPips > 0 ? `1:${formatNumber(plan.rrPips, 1, false)}` : 'N/A',
                "RRSL": plan.rrPercentage ? formatNumber(plan.rrPercentage.sl, 2) : 'N/A',
                "RRTP": plan.rrPercentage ? formatNumber(plan.rrPercentage.tp, 2) : 'N/A',
                "LotUnits": formatNumber(plan.lotSize, 2),
                "NettSL": plan.nettSL,
                "NettTP": plan.nettTP,
                "Catatan": plan.note || '-',
                "Hasil": plan.outcome || 'N/A',
                "WaktuKeluar": plan.timestamp ? new Date(plan.timestamp).toLocaleString('id-ID') : 'N/A'
            };
        }


        if (downloadExecutedExcelBtn) {
            downloadExecutedExcelBtn.addEventListener('click', () => {
                const headers = ["Status", "Aset", "Trade", "BalanceAkun", "WaktuMasuk", "OpenPrice", "SLPrice", "TPPrice", "PendingPipsPoints", "SLPipsPoints", "TPPipsPoints", "RRPips", "RRSL", "RRTP", "LotUnits", "NettSL", "NettTP", "Catatan", "Hasil", "WaktuKeluar"];
                const dataToExport = executedPlansData.map(plan => preparePlanForExport(plan, 'Selesai'));
                downloadAsExcel(`Rencana_Trading_Selesai_${new Date().toISOString().slice(0, 10)}.csv`, dataToExport, headers);
            });
        }
        
        if (downloadAllExcelBtn) {
            downloadAllExcelBtn.addEventListener('click', () => {
                const headers = ["Status", "Aset", "Trade", "BalanceAkun", "WaktuMasuk", "OpenPrice", "SLPrice", "TPPrice", "PendingPipsPoints", "SLPipsPoints", "TPPipsPoints", "RRPips", "RRSL", "RRTP", "LotUnits", "NettSL", "NettTP", "Catatan", "Hasil", "WaktuKeluar"];
                
                const allData = [
                    ...calculatedPlansData.map(p => preparePlanForExport(p, 'Baru')),
                    ...runningPlansData.map(p => preparePlanForExport(p, 'Aktif')),
                    ...executedPlansData.map(p => preparePlanForExport(p, 'Selesai'))
                ];

                downloadAsExcel(`Semua_Data_Trading_${new Date().toISOString().slice(0, 10)}.csv`, allData, headers);
            });
        }
        
        // --- FIX: Define the missing function ---
        function exportMonthlySummaryToExcel() {
            const tableBody = document.getElementById('monthlySummaryTableBody');
            if (!tableBody || tableBody.rows.length === 0 || (tableBody.rows.length === 1 && tableBody.rows[0].cells[0].colSpan === 4)) {
                showMessageBox('Informasi', 'Tidak ada data ringkasan bulanan untuk diunduh.', false);
                return;
            }

            const headers = ['Bulan', 'PL_Percent', 'Total_Trade', 'Saldo_Akhir'];
            const dataToExport = Array.from(tableBody.rows).map(row => {
                const cells = row.cells;
                return {
                    Bulan: cells[0].innerText.trim(),
                    PL_Percent: cells[1].innerText.trim().replace('%', ''),
                    Total_Trade: cells[2].innerText.trim(),
                    Saldo_Akhir: cells[3].innerText.trim().replace('$', '').replace(/,/g, '')
                };
            });
            
            downloadAsExcel(`Ringkasan_Bulanan_${new Date().toISOString().slice(0, 10)}.csv`, dataToExport, headers);
        }

        if (downloadMonthlySummaryBtn) {
            downloadMonthlySummaryBtn.addEventListener('click', exportMonthlySummaryToExcel);
        }
        // --- END OF FIX ---

        async function exportToPdf(elementId, filename) {
            const element = document.getElementById(elementId);
            if (!element) { console.log('Elemen tidak ditemukan untuk diunduh PDF.'); return; }
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.7);color:white;padding:20px;border-radius:10px;z-index:1000;';
            loadingDiv.textContent = 'Membuat PDF...'; document.body.appendChild(loadingDiv);
            try {
                const canvas = await html2canvas(element, { scale: 2 });
                const imgData = canvas.toDataURL('image/png'); const { jsPDF } = window.jspdf; const pdf = new jsPDF('p', 'mm', 'a4');
                const imgWidth = 210; const pageHeight = 297; const imgHeight = canvas.height * imgWidth / canvas.width;
                let heightLeft = imgHeight; let position = 0;
                pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight); heightLeft -= pageHeight;
                while (heightLeft >= 0) { position = heightLeft - imgHeight; pdf.addPage(); pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight); heightLeft -= pageHeight; }
                pdf.save(filename);
            } catch (error) { console.error("Error generating PDF:", error); console.log('Gagal membuat PDF: ' + error.message); }
            finally { document.body.removeChild(loadingDiv); }
        }

        // --- Photo Upload & Crop Functions ---
        function drawImageCover(ctx, img, canvasWidth, canvasHeight, targetAspectRatio) {
            const imgAspectRatio = img.width / img.height;
            let sx, sy, sWidth, sHeight;

            if (imgAspectRatio > targetAspectRatio) {
                sHeight = img.height;
                sWidth = sHeight * targetAspectRatio;
                sx = (img.width - sWidth) / 2;
                sy = 0;
            } else {
                sWidth = img.width;
                sHeight = sWidth / targetAspectRatio;
                sx = 0;
                sy = (img.height - sHeight) / 2;
            }
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, canvasWidth, canvasHeight);
        }

        function renderPhotoGallery() {
            if (!photoSlides) return;
            photoSlides.innerHTML = '';
            const photoArray = userPhotos;

            if (photoArray.length === 0) {
                photoSlides.innerHTML = '<img src="https://placehold.co/400x400/cccccc/ffffff?text=Add+Photos" alt="Placeholder" class="w-full h-full object-cover flex-shrink-0">';
                if (photoCounter) photoCounter.classList.add('hidden');
            } else {
                photoArray.forEach((photoUrl, index) => {
                    const img = document.createElement('img');
                    img.src = photoUrl;
                    img.alt = `User Photo ${index + 1}`;
                    img.className = 'w-full h-full object-cover flex-shrink-0';
                    photoSlides.appendChild(img);
                });
                if (photoCounter) photoCounter.textContent = `${currentPhotoIndex + 1} / ${photoArray.length}`;
                if (photoCounter) photoCounter.classList.toggle('hidden', photoArray.length === 0);
            }
        }
        
        function renderPhotoGallery16x9() {
            if (!gallery16x9Container) return;
            gallery16x9Container.innerHTML = ''; // Clear existing images
            const photoArray = userPhotos16x9;

            if (photoArray.length === 0) {
                gallery16x9Container.innerHTML = '<img src="https://placehold.co/1920x1080/cccccc/ffffff?text=Add+16:9+Photos" alt="Placeholder 16:9" class="gallery-16x9-slide">';
            } else {
                photoArray.forEach((photoUrl, index) => {
                    const img = document.createElement('img');
                    img.src = photoUrl;
                    img.alt = `User Photo 16:9 ${index + 1}`;
                    img.className = 'gallery-16x9-slide';
                    gallery16x9Container.appendChild(img);
                });
            }
        }

        function startAutoScroll16x9() {
            clearInterval(autoScrollInterval16x9); // Clear any existing interval
            autoScrollInterval16x9 = setInterval(() => {
                if (gallery16x9Container) {
                    const scrollWidth = gallery16x9Container.scrollWidth;
                    const clientWidth = gallery16x9Container.clientWidth;
                    if (gallery16x9Container.scrollLeft + clientWidth >= scrollWidth) {
                        gallery16x9Container.scrollLeft = 0;
                    } else {
                        gallery16x9Container.scrollLeft += clientWidth;
                    }
                }
            }, 5000); // 5000ms = 5 detik
        }


        // --- PERBAIKAN: Fungsi penangan tekan lama (Long Press) ---
        function addLongPressListener(element, galleryType) {
            if (!element) return;

            let longPressTimer;
            let isLongPress = false;
            const LONG_PRESS_THRESHOLD = 200; // 200ms
            const MOVE_THRESHOLD = 10; // pixels
            let startX, startY;

            const handlePressStart = (e) => {
                startX = (e.touches ? e.touches[0] : e).clientX;
                startY = (e.touches ? e.touches[0] : e).clientY;
                isLongPress = false;

                longPressTimer = setTimeout(async () => {
                    isLongPress = true;
                    // Mencegah event klik default setelah tekan lama
                    if (e.type === 'touchstart') e.preventDefault();

                    const photoArray = galleryType === '1:1' ? userPhotos : userPhotos16x9;
                    if (photoArray.length === 0) return;

                    const confirmed = await showMessageBox('Hapus Foto?', 'Apakah Anda yakin ingin menghapus foto ini?', true);
                    if (confirmed) {
                        const indexToDelete = Math.round(element.scrollLeft / element.clientWidth);
                        
                        if (db && userId !== 'anonymous') {
                            await deleteProfilePicture(userId, indexToDelete, galleryType);
                        } else {
                            // Fallback untuk local storage
                            photoArray.splice(indexToDelete, 1);
                            savePhotosToLocalStorage(galleryType);
                            if (galleryType === '1:1') renderPhotoGallery(); else renderPhotoGallery16x9();
                        }
                        showMessageBox('Berhasil', 'Foto berhasil dihapus.', false);
                    }
                }, LONG_PRESS_THRESHOLD);
            };

            const handlePressEnd = (e) => {
                clearTimeout(longPressTimer);
                if (isLongPress) {
                    e.preventDefault(); // Mencegah klik jika itu adalah tekan lama
                }
            };

            const handlePressMove = (e) => {
                if (!longPressTimer) return;
                const currentX = (e.touches ? e.touches[0] : e).clientX;
                const currentY = (e.touches ? e.touches[0] : e).clientY;
                if (Math.abs(currentX - startX) > MOVE_THRESHOLD || Math.abs(currentY - startY) > MOVE_THRESHOLD) {
                    clearTimeout(longPressTimer);
                }
            };

            // Tambahkan event listener untuk desktop dan mobile
            element.addEventListener('mousedown', handlePressStart);
            element.addEventListener('mouseup', handlePressEnd);
            element.addEventListener('mouseleave', handlePressEnd); // Juga batalkan jika mouse meninggalkan elemen
            element.addEventListener('mousemove', handlePressMove);

            element.addEventListener('touchstart', handlePressStart, { passive: false });
            element.addEventListener('touchend', handlePressEnd);
            element.addEventListener('touchmove', handlePressMove);
        }
        
        // --- PERBAIKAN: Fungsi unggah dan potong foto ---
        function handleImageUpload(event, galleryType) {
            const photoArray = galleryType === '1:1' ? userPhotos : userPhotos16x9;
            if (photoArray.length >= MAX_PHOTOS) {
                showMessageBox('Batas Unggahan Tercapai', `Anda hanya dapat mengunggah maksimal ${MAX_PHOTOS} foto.`, false);
                event.target.value = ''; return;
            }
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                currentUploadTarget = galleryType;
                const reader = new FileReader();
                reader.onload = (e) => {
                    currentImageToCrop = new Image();
                    currentImageToCrop.onload = () => {
                        if (photoUploadModal) showModal(photoUploadModal);
                        
                        // --- PERBAIKAN: Atur aspek rasio kanvas sesuai tipe galeri ---
                        const targetAspectRatio = galleryType === '1:1' ? 1 : 16 / 9;
                        const canvasContainer = imageCanvas.parentElement;
                        const containerWidth = canvasContainer.clientWidth;
                        
                        imageCanvas.width = containerWidth;
                        imageCanvas.height = containerWidth / targetAspectRatio;
                        
                        // Sesuaikan juga style untuk memastikan tampilan visual benar
                        imageCanvas.style.aspectRatio = `${targetAspectRatio}`;
                        
                        drawImageCover(ctx, currentImageToCrop, imageCanvas.width, imageCanvas.height, targetAspectRatio);
                    };
                    currentImageToCrop.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else { showMessageBox('Gagal', 'Silakan pilih file gambar yang valid.', false); }
            event.target.value = '';
        }

        if (imageInput) imageInput.addEventListener('change', (e) => handleImageUpload(e, '1:1'));
        if (imageInput16x9) imageInput16x9.addEventListener('change', (e) => handleImageUpload(e, '16:9'));

        if (cropAndSaveBtn) {
            cropAndSaveBtn.addEventListener('click', async () => {
                if (currentImageToCrop && imageCanvas) {
                    const imageDataUrl = imageCanvas.toDataURL('image/png');
                    const photoArray = currentUploadTarget === '1:1' ? userPhotos : userPhotos16x9;
                    const targetIndex = photoArray.length;
                    if (db && userId !== 'anonymous') {
                        await saveProfilePicture(userId, imageDataUrl, targetIndex, currentUploadTarget);
                    } else {
                        photoArray.push(imageDataUrl);
                        savePhotosToLocalStorage(currentUploadTarget);
                        showMessageBox('Berhasil', 'Foto berhasil disimpan.', false);
                    }
                    if (currentUploadTarget === '1:1') {
                        currentPhotoIndex = targetIndex;
                        renderPhotoGallery();
                    } else {
                        renderPhotoGallery16x9();
                    }
                    if (photoUploadModal) hideModal(photoUploadModal);
                    currentImageToCrop = null;
                }
            });
        }

        if (cancelPhotoBtn) cancelPhotoBtn.addEventListener('click', () => {
            if (photoUploadModal) hideModal(photoUploadModal);
            currentImageToCrop = null;
        });

        // --- Limit Checking Logic (Refactored for single pass) ---
        function checkTradeLimits() {
            let overallInitialBalance = null, overallCurrentBalance = null, monthlyInitialBalance = null, monthlyCurrentBalance = null, dailyInitialBalance = null, dailyCurrentBalance = null;
            const now = new Date(); const currentMonthYearIdentifier = `${now.getFullYear()}-${now.getMonth()}`; const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();

            executedPlansData.forEach(trade => {
                if (trade.outcome === 'Cancel') {
                    console.log("Skipping cancelled trade:", trade);
                    return;
                }
                const profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                const tradeDate = new Date(trade.timestamp); const tradeTimestamp = tradeDate.getTime();
                const tradeMonthYearIdentifier = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;

                // Overall balance calculation
                if (overallInitialBalance === null) { overallInitialBalance = trade.balance; overallCurrentBalance = trade.balance; }
                overallCurrentBalance += profitLossAmount;

                // Monthly balance calculation
                if (tradeMonthYearIdentifier === currentMonthYearIdentifier) {
                    if (monthlyInitialBalance === null) { monthlyInitialBalance = trade.balance; monthlyCurrentBalance = trade.balance; }
                    monthlyCurrentBalance += profitLossAmount;
                }
                // Daily balance calculation
                if (tradeTimestamp >= todayStart && tradeTimestamp <= now.getTime()) {
                    if (dailyInitialBalance === null) { dailyInitialBalance = trade.balance; dailyCurrentBalance = trade.balance; }
                    dailyCurrentBalance += profitLossAmount;
                }
            });
            
            const overallCumulativePercentageLoss = (overallInitialBalance !== null && overallInitialBalance !== 0) ? ((overallCurrentBalance - overallInitialBalance) / overallInitialBalance) * 100 : 0;
            const currentMonthPercentageLoss = (monthlyInitialBalance !== null && monthlyInitialBalance !== 0) ? ((monthlyCurrentBalance - monthlyInitialBalance) / monthlyInitialBalance) * 100 : 0;
            const currentDailyPercentageLoss = (dailyInitialBalance !== null && dailyInitialBalance !== 0) ? ((dailyCurrentBalance - dailyInitialBalance) / dailyInitialBalance) * 100 : 0;

            const lastOverallLossBreachMonth = localStorage.getItem('lastOverallLossBreachMonth');
            if (overallCumulativePercentageLoss <= OVERALL_MAX_LOSS_LIMIT) {
                if (lastOverallLossBreachMonth === currentMonthYearIdentifier) { limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(OVERALL_MAX_LOSS_LIMIT)}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`; return false; }
                else { localStorage.setItem('lastOverallLossBreachMonth', currentMonthYearIdentifier); limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(OVERALL_MAX_LOSS_LIMIT)}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`; return false; }
            } else { if (lastOverallLossBreachMonth === currentMonthYearIdentifier) localStorage.removeItem('lastOverallLossBreachMonth'); }
            if (currentMonthPercentageLoss <= MONTHLY_LOSS_LIMIT) { limitNotificationMessage = `Anda telah mencapai batas kerugian bulanan maksimum (-${Math.abs(MONTHLY_LOSS_LIMIT)}%). Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`; return false; }
            if (currentDailyPercentageLoss <= DAILY_LOSS_LIMIT) { limitNotificationMessage = `Anda telah mencapai batas kerugian harian (-${Math.abs(DAILY_LOSS_LIMIT)}%). Input data akan diaktifkan kembali pada hari berikutnya.`; return false; }
            limitNotificationMessage = ''; return true;
        }

        function displayLimitNotification(message) {
            const notificationDiv = document.getElementById('limitNotification');
            if (notificationDiv) { // Add null check here
                if (message) { notificationDiv.textContent = message; notificationDiv.classList.remove('hidden', 'error-message'); notificationDiv.classList.add('error-message'); }
                 else { notificationDiv.textContent = ''; notificationDiv.classList.add('hidden'); notificationDiv.classList.remove('error-message'); }
            }
        }

        // --- EVENT LISTENERS ---
        const addInputRowBtn = document.getElementById('addInputRowBtn');
        if (addInputRowBtn) { // Add null check here
            addInputRowBtn.addEventListener('click', () => {
                if (checkTradeLimits()) { addInputRow(); saveInputRowsToLocalStorage(); displayLimitNotification(''); }
                else { displayLimitNotification(limitNotificationMessage); }
            });
        }
        const calculateAllBtn = document.getElementById('calculateAllBtn');
        if (calculateAllBtn) { // Add null check here
            calculateAllBtn.addEventListener('click', () => { calculateAllRows(); saveDataToLocalStorage(); });
        }

        // --- DELETE AND EXPORT DATA FUNCTIONALITY ---
        if (deleteAndExportDataBtn) { // Add null check here
            deleteAndExportDataBtn.addEventListener('click', async () => {
                if (executedPlansData.length === 0) {
                    showMessageBox('Informasi', 'Tidak ada data rencana trading yang selesai untuk diunduh atau dihapus.', false);
                    return;
                }
                const confirmed = await showMessageBox('Hapus Semua Data Trading?', 'Apakah Anda yakin ingin mengunduh dan menghapus semua data rencana trading selesai?', true);
                if (!confirmed) {
                    showMessageBox('Dibatalkan', 'Penghapusan data dibatalkan.', false);
                    return;
                }

                const headers = ['Aset', 'Trade', 'Balance Akun', 'Waktu Masuk', 'Open Price', 'SL Price', 'TP Price', 'Pending Pips/Points', 'SL Pips/Points', 'TP Pips/Points', 'R:R Pips', 'R:R % SL', 'R:R % TP', 'Lot/Units', 'Nett SL', 'Nett TP', 'Catatan', 'Hasil', 'Waktu Keluar'];
                const dataToExport = executedPlansData.map(plan => [
                    plan.symbol || 'N/A',
                    plan.tradeType, formatCurrency(plan.balance, 'USD').replace(/,/g, ''), new Date(plan.entryTime).toLocaleString('id-ID'), formatNumber(plan.openPrice, plan.assetData.decimals, false),
                    formatNumber(plan.slPrice, plan.assetData.decimals, false),
                    formatNumber(plan.tpPrice, plan.assetData.decimals, false),
                    getVisualPoints(plan.pendingPips).display,
                    getVisualPoints(plan.slPips).display,
                    getVisualPoints(plan.tpPips).display,
                    plan.rrPips > 0 ? `1:${formatNumber(plan.rrPips, 1, false)}` : 'N/A',
                    formatNumber(plan.rrPercentage.sl, 2), formatNumber(plan.rrPercentage.tp, 2),
                    formatNumber(plan.lotSize, 2), formatCurrency(plan.nettSL, 'USD').replace(/,/g, ''), formatCurrency(plan.nettTP, 'USD').replace(/,/g, ''), plan.note || '-',
                    plan.outcome, new Date(plan.timestamp).toLocaleString('id-ID')
                ]);
                exportToCsv(`Rencana_Trading_Selesai_${new Date().toISOString().slice(0, 10)}.csv`, dataToExport, headers);

                try {
                    if (db && userId !== 'anonymous') {
                        await deleteAllExecutedPlans(userId);
                    }
                    executedPlansData = []; localStorage.removeItem('lastOverallLossBreachMonth'); saveDataToLocalStorage();
                    renderExecutedPlans(); 
                    calculateSummaryStatistics(); 
                    updateRiskRewardStatistics();
                    for (const sectionId in chartSections) {
                        const chartInfo = chartSections[sectionId];
                        if (chartInfo.chartInstance && chartInfo.chartInstance()) { chartInfo.chartInstance().destroy(); chartInfo.setInstance(null); chartInfo.hasRendered = false; }
                    }
                    checkTradeLimits(); displayLimitNotification(limitNotificationMessage);
                    showMessageBox('Berhasil', 'Data rencana trading selesai telah diunduh dan dihapus.', false);
                } catch (error) {
                    console.error("Error during delete and export:", error);
                    showMessageBox('Gagal', 'Terjadi kesalahan saat menghapus data. Silakan coba lagi.', false);
                }
            });
        }
        
        

        // --- UPLOAD DATA FUNCTIONALITY ---
        const hiddenFileInput = document.createElement('input');
        hiddenFileInput.type = 'file'; hiddenFileInput.accept = '.csv'; hiddenFileInput.style.display = 'none';
        document.body.appendChild(hiddenFileInput);
        if (uploadDataBtn) {
            uploadDataBtn.addEventListener('click', async () => {
                const confirmed = await showMessageBox('Unggah Data Trading?', 'Mengunggah data akan menimpa semua data "Rencana Trading Selesai" yang ada. Lanjutkan?', true);
                if (confirmed) {
                    hiddenFileInput.click();
                } else {
                    showMessageBox('Dibatalkan', 'Pengunggahan data dibatalkan.', false);
                }
            });
        }
        hiddenFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => { // Made onload async
                    try {
                        const parsedData = parseCSV(e.target.result);
                        if (db && userId !== 'anonymous') {
                            // Delete existing data in Firestore before uploading new
                            await deleteAllExecutedPlans(userId);
                            // Add new data to Firestore
                            const savePromises = parsedData.map(plan => saveExecutedPlan(userId, plan));
                            await Promise.all(savePromises);
                            showMessageBox('Berhasil', 'Data berhasil diunggah dan diimpor.', false); // Success message
                        } else {
                            importExecutedPlans(parsedData); // Fallback to local storage
                            showMessageBox('Berhasil', 'Data berhasil diunggah dan diimpor ke Local Storage.', false); // Success message for local storage
                        }
                    }
                    catch (error) {
                        console.error('Error parsing or importing CSV:', error);
                        showMessageBox('Gagal Unggah Data', 'Terjadi kesalahan saat mengunggah data. Pastikan format file CSV benar.', false); // Error message
                    }
                    finally { hiddenFileInput.value = ''; }
                };
                reader.readAsText(file);
            }
        });

        function parseCSV(csvString) {
            const lines = csvString.trim().split('\n'); if (lines.length === 0) return [];
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            const dataRows = lines.slice(1);
            const headerMap = {
                'Aset': 'symbol', 'Trade': 'tradeType', 'Balance Akun': { key: 'balance', type: 'float', clean: (val) => parseFloat(val.replace(/[^0-9.-]+/g, "")) },
                'Waktu Masuk': { key: 'entryTime', type: 'date' }, 'Open Price': { key: 'openPrice', type: 'float' }, 'SL Price': { key: 'slPrice', type: 'float' },
                'TP Price': { key: 'tpPrice', type: 'float' }, 
                // --- START OF FIX: Import visual points and convert back to pips ---
                'Pending Pips/Points': { key: 'pendingPips', type: 'float', clean: (val) => parseFloat(val) / 10 }, 
                'SL Pips/Points': { key: 'slPips', type: 'float', clean: (val) => parseFloat(val) / 10 },
                'TP Pips/Points': { key: 'tpPips', type: 'float', clean: (val) => parseFloat(val) / 10 },
                // --- END OF FIX ---
                'R:R Pips': { key: 'rrPips', type: 'float', clean: (val) => parseFloat(val.replace('1:', '')) },
                'R:R % SL': { key: 'rrPercentageSL', type: 'float', clean: (val) => parseFloat(val.replace('%', '')) },
                'R:R % TP': { key: 'rrPercentageTP', type: 'float', clean: (val) => parseFloat(val.replace('%', '')) },
                'Lot/Units': { key: 'lotSize', type: 'float' }, 'Nett SL': { key: 'nettSL', type: 'float', clean: (val) => parseFloat(val.replace(/[^0-9.-]+/g, "")) },
                'Nett TP': { key: 'nettTP', type: 'float', clean: (val) => parseFloat(val.replace(/[^0-9.-]+/g, "")) },
                'Catatan': 'note', 'Hasil': 'outcome', 'Waktu Keluar': { key: 'timestamp', type: 'date' }
            };
             return dataRows.map(row => {
                const values = row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim().replace(/"/g, ''));
               const newPlan = {};
                headers.forEach((header, index) => {
                    const map = headerMap[header]; let value = values[index];
                    if (map) {
                        if (typeof map === 'string') newPlan[map] = value;
                        else {
                            if (map.clean) value = map.clean(value);
                            else if (map.type === 'float') value = parseFloat(value);
                            else if (map.type === 'date') { const date = new Date(value); value = isNaN(date.getTime()) ? null : date.toISOString(); if (isNaN(date.getTime())) console.warn(`Invalid date value for header '${header}': '${values[index]}'. Setting to null.`); }
                            newPlan[map.key] = value;
                        }
                    }
                });
                newPlan.rrPercentage = { sl: newPlan.rrPercentageSL, tp: newPlan.rrPercentageTP }; delete newPlan.rrPercentageSL; delete newPlan.rrPercentageTP;
                newPlan.assetData = getAssetData(newPlan.symbol);
                newPlan.rowId = `imported-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                if (newPlan.outcome === 'Stop Loss' && newPlan.slPips > 0) newPlan.slPips = -Math.abs(newPlan.slPips);
                else if (newPlan.outcome === 'Take Profit' && newPlan.tpPips < 0) newPlan.tpPips = Math.abs(newPlan.tpPips);
                return newPlan;
            }).filter(plan => plan.symbol && plan.tradeType && plan.balance);
        }

        function importExecutedPlans(data) {
            executedPlansData = data; saveDataToLocalStorage(); renderExecutedPlans();
            checkTradeLimits(); displayLimitNotification(limitNotificationMessage);
            calculateSummaryStatistics(); 
            updateRiskRewardStatistics();
            calculateAndRenderMonthlyPLSummary(); // NEW: Call monthly summary function
            for (const sectionId in chartSections) {
                const chartInfo = chartSections[sectionId];
                if (chartInfo.chartInstance && chartInfo.chartInstance()) { chartInfo.chartInstance().destroy(); chartInfo.setInstance(null); chartInfo.hasRendered = false; }
            }
            console.log("Executed plans imported and re-rendered.");
        }

        // --- SUMMARY STATISTICS CALCULATION AND DISPLAY ---
        function calculateSummaryStatistics() {
            console.log("Calculating summary statistics...");
            let totalPips = 0, initialBalance = null, finalBalance = null, firstTradeDate = null, totalTakeProfitTrades = 0, totalNonCancelledTrades = 0, totalSettledTrades = 0;
            let peakBalance = -Infinity, maxDrawdownPercentage = 0;

            executedPlansData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            executedPlansData.forEach(trade => {
                if (trade.outcome === 'Cancel') return;
                
                totalNonCancelledTrades++;
                totalSettledTrades++;

                if (trade.outcome === 'Take Profit') totalTakeProfitTrades++;
                if (firstTradeDate === null) firstTradeDate = new Date(trade.timestamp);

                let profitLossAmount = (trade.outcome === 'Take Profit') ? trade.nettTP : (trade.outcome === 'Stop Loss' ? trade.nettSL : 0);
                // --- START OF FIX: Use visual points for summary ---
                let pointsForTrade = 0;
                if (trade.outcome === 'Take Profit') {
                    pointsForTrade = getVisualPoints(trade.tpPips).forCalc;
                } else if (trade.outcome === 'Stop Loss') {
                    pointsForTrade = -getVisualPoints(trade.slPips).forCalc;
                }
                totalPips += pointsForTrade;
                // --- END OF FIX ---

                if (initialBalance === null) {
                    initialBalance = trade.balance;
                    finalBalance = trade.balance;
                    peakBalance = finalBalance; // Initialize peak balance
                }
                
                finalBalance += profitLossAmount;

                // Calculate drawdown
                if (finalBalance > peakBalance) {
                    peakBalance = finalBalance;
                }
                if (peakBalance > 0) {
                    const currentDrawdown = ((peakBalance - finalBalance) / peakBalance) * 100;
                    if (currentDrawdown > maxDrawdownPercentage) {
                        maxDrawdownPercentage = currentDrawdown;
                    }
                }
            });

               const totalSettledTradesSummaryElement = document.getElementById('totalSettledTradesSummary');
            const totalPipsElement = document.getElementById('totalPipsSummary');
            const overallPercentageElement = document.getElementById('overallPercentageSummary');
            const finalBalanceElement = document.getElementById('finalBalanceSummary');
            const probabilitySummaryElement = document.getElementById('probabilitySummary');
            const joinTimeSummaryElement = document.getElementById('joinTimeSummary');

            console.log("Summary Calculation Results:");
            console.log("totalSettledTrades:", totalSettledTrades);
            console.log("totalPips:", totalPips);
            console.log("initialBalance:", initialBalance);
            console.log("finalBalance:", finalBalance);
            console.log("totalTakeProfitTrades:", totalTakeProfitTrades);
            console.log("totalNonCancelledTrades:", totalNonCancelledTrades);
            console.log("firstTradeDate:", firstTradeDate);


            if (executedPlansData.length === 0 || totalSettledTrades === 0) { // Added totalSettledTrades === 0 check
                if (totalSettledTradesSummaryElement) totalSettledTradesSummaryElement.textContent = 'N/A';
                if (totalPipsElement) totalPipsElement.textContent = 'N/A';
                if (overallPercentageElement) overallPercentageElement.textContent = 'N/A';
                if (finalBalanceElement) finalBalanceElement.textContent = 'N/A';
                if (probabilitySummaryElement) probabilitySummaryElement.textContent = 'N/A';
                if (joinTimeSummaryElement) joinTimeSummaryElement.textContent = 'N/A'; // Set to N/A if no trades
                if (totalPipsElement) totalPipsElement.classList.remove('negative-summary-value');
                if (overallPercentageElement) overallPercentageElement.classList.remove('negative-summary-value');
                if (finalBalanceElement) finalBalanceElement.classList.remove('negative-summary-value');
                console.log("No relevant executed plans data for summary statistics. Displaying N/A.");
                return;
            }
            let overallPercentageChange = (initialBalance !== null && initialBalance !== 0) ? ((finalBalance - initialBalance) / initialBalance) * 100 : 0;
            const probability = totalNonCancelledTrades > 0 ? (totalTakeProfitTrades / totalNonCancelledTrades) * 100 : 0;

            console.log("overallPercentageChange:", overallPercentageChange);
            console.log("probability:", probability);

            if (totalSettledTradesSummaryElement) totalSettledTradesSummaryElement.textContent = totalSettledTrades;
            if (totalSettledTradesSummaryElement) totalSettledTradesSummaryElement.classList.remove('negative-summary-value'); // Should not be negative

            if (totalPipsElement) totalPipsElement.textContent = formatNumber(totalPips, 0); // Display the calculated visual total
            if (totalPipsElement) totalPipsElement.classList.toggle('negative-summary-value', totalPips < 0);

            if (overallPercentageElement) overallPercentageElement.textContent = formatNumber(overallPercentageChange, 2) + '%';
            if (overallPercentageElement) overallPercentageElement.classList.toggle('negative-summary-value', overallPercentageChange < 0);

            if (finalBalanceElement) finalBalanceElement.textContent = formatCurrency(finalBalance, 'USD');
            if (finalBalanceElement) finalBalanceElement.classList.toggle('negative-summary-value', finalBalance < initialBalance || finalBalance < 0);

            if (probabilitySummaryElement) probabilitySummaryElement.textContent = formatNumber(probability, 2) + '%';
            if (probabilitySummaryElement) probabilitySummaryElement.classList.remove('negative-summary-value'); // Probability won't be negative

            // Update join time based on the first trade
            if (joinTimeSummaryElement) { // Add null check here
                if (firstTradeDate) {
                    joinTimeSummaryElement.textContent = firstTradeDate.toLocaleDateString('id-ID', { year: 'numeric', month: 'long', day: 'numeric' });
                } else {
                    joinTimeSummaryElement.textContent = 'N/A';
                }
            }
            console.log("Summary statistics calculated and displayed.");
        }

        // --- RISK AND REWARD STATISTICS CALCULATION AND DISPLAY ---
        function updateRiskRewardStatistics() {
            console.log("Updating risk and reward statistics...");
            const relevantTrades = executedPlansData.filter(trade => trade.outcome !== 'Cancel');
            if (relevantTrades.length === 0) {
                if (document.getElementById('avgRiskReward')) document.getElementById('avgRiskReward').innerHTML = `1 : <span class="text-black">N/A</span>`;
                ['avgSignalSettledMonth', 'avgHoldingPeriod', 'avgTpPips', 'avgSlPips', 'consecutiveProfit', 'consecutiveLoss', 'averagePips', 'grossProfit', 'grossLoss', 'avgSignalSettledWeek', 'maxHoldingPeriod', 'maxTpPips', 'maxSlPips'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = `<span class="text-black">N/A</span>`;
                });
                console.log("No relevant trades for risk and reward statistics."); return;
            }

          let totalTpPips = 0, countTpTrades = 0, totalSlPipsAbsolute = 0, countSlTrades = 0, totalPips = 0, grossProfit = 0, grossLoss = 0, totalHoldingPeriodMs = 0, maxHoldingPeriodMs = 0;
            let maxTpPips = -Infinity, maxSlPips = Infinity;
            let currentProfitStreak = 0, maxProfitStreak = 0, currentProfitAmount = 0, maxProfitAmount = 0;
            let currentLossStreak = 0, maxLossStreak = 0, currentLossAmount = 0, maxLossAmount = 0;
            const monthlyTradeCounts = {}, weeklyTradeCounts = {};

            relevantTrades.forEach(trade => {
                const tradeDate = new Date(trade.timestamp);
                if (trade.entryTime) {
                    const holdingDuration = tradeDate.getTime() - new Date(trade.entryTime).getTime();
                    totalHoldingPeriodMs += holdingDuration; if (holdingDuration > maxHoldingPeriodMs) maxHoldingPeriodMs = holdingDuration;
                }
                if (trade.outcome === 'Take Profit') {
                    totalTpPips += trade.tpPips; countTpTrades++; totalPips += trade.tpPips; grossProfit += trade.nettTP; if (trade.tpPips > maxTpPips) maxTpPips = trade.tpPips;
                    currentProfitStreak++; currentProfitAmount += trade.nettTP;
                    if (currentProfitStreak > maxProfitStreak) { maxProfitStreak = currentProfitStreak; maxProfitAmount = currentProfitAmount; }
                    currentLossStreak = 0; currentLossAmount = 0;
                } else if (trade.outcome === 'Stop Loss') {
                    totalSlPipsAbsolute += Math.abs(trade.slPips); countSlTrades++; totalPips += trade.slPips; grossLoss += trade.nettSL; if (trade.slPips < maxSlPips) maxSlPips = trade.slPips;
                    currentLossStreak++; currentLossAmount += trade.nettSL;
                    if (currentLossStreak > maxLossStreak) { maxLossStreak = currentLossStreak; maxLossAmount = currentLossAmount; }
                    currentProfitStreak = 0; currentProfitAmount = 0;
                }
                const monthYear = `${tradeDate.getFullYear()}-${(tradeDate.getMonth() + 1).toString().padStart(2, '0')}`; monthlyTradeCounts[monthYear] = (monthlyTradeCounts[monthYear] || 0) + 1;
                const startOfYear = new Date(tradeDate.getFullYear(), 0, 1);
                const weekNumber = Math.ceil((Math.floor((tradeDate - startOfYear) / (24 * 3600 * 1000)) + startOfYear.getDay() + 1) / 7);
                weeklyTradeCounts[`${tradeDate.getFullYear()}-${String(weekNumber).padStart(2, '0')}`] = (weeklyTradeCounts[`${tradeDate.getFullYear()}-${String(weekNumber).padStart(2, '0')}`] || 0) + 1;
            });

            const avgTpPips = countTpTrades > 0 ? totalTpPips / countTpTrades : 0;
            const avgSlPips = countSlTrades > 0 ? totalSlPipsAbsolute / countSlTrades : 0;
            const avgRiskReward = (avgSlPips > 0) ? avgTpPips / avgSlPips : 0;
            const avgPips = relevantTrades.length > 0 ? totalPips / relevantTrades.length : 0;
            const avgHoldingPeriodMs = relevantTrades.length > 0 ? totalHoldingPeriodMs / relevantTrades.length : 0;
            const avgSignalSettledMonth = Object.keys(monthlyTradeCounts).length > 0 ? Object.values(monthlyTradeCounts).reduce((sum, count) => sum + count, 0) / Object.keys(monthlyTradeCounts).length : 0;
           const avgSignalSettledWeek = Object.keys(weeklyTradeCounts).length > 0 ? Object.values(weeklyTradeCounts).reduce((sum, count) => sum + count, 0) / Object.keys(weeklyTradeCounts).length : 0;

            if (document.getElementById('avgRiskReward')) document.getElementById('avgRiskReward').innerHTML = `1 : ${getColoredValueHtml(avgRiskReward, false, 1)}`;
            if (document.getElementById('avgSignalSettledMonth')) document.getElementById('avgSignalSettledMonth').innerHTML = getColoredValueHtml(avgSignalSettledMonth, false, 0);
            if (document.getElementById('avgHoldingPeriod')) document.getElementById('avgHoldingPeriod').innerHTML = formatDuration(avgHoldingPeriodMs);
            if (document.getElementById('avgTpPips')) document.getElementById('avgTpPips').innerHTML = getColoredValueHtml(avgTpPips, false, 1);
            if (document.getElementById('avgSlPips')) document.getElementById('avgSlPips').innerHTML = getColoredValueHtml(avgSlPips, false, 1);
            if (document.getElementById('consecutiveProfit')) document.getElementById('consecutiveProfit').innerHTML = `${getColoredValueHtml(maxProfitStreak, false, 0)} (${getColoredValueHtml(maxProfitAmount, true)})`;
            if (document.getElementById('consecutiveLoss')) document.getElementById('consecutiveLoss').innerHTML = `${getColoredValueHtml(maxLossStreak, false, 0)} (${getColoredValueHtml(maxLossAmount, true)})`;
            if (document.getElementById('averagePips')) document.getElementById('averagePips').innerHTML = getColoredValueHtml(avgPips, false, 1);
            if (document.getElementById('grossProfit')) document.getElementById('grossProfit').innerHTML = getColoredValueHtml(grossProfit, true);
            if (document.getElementById('grossLoss')) document.getElementById('grossLoss').innerHTML = getColoredValueHtml(grossLoss, true);
            if (document.getElementById('avgSignalSettledWeek')) document.getElementById('avgSignalSettledWeek').innerHTML = getColoredValueHtml(avgSignalSettledWeek, false, 0);
            if (document.getElementById('maxHoldingPeriod')) document.getElementById('maxHoldingPeriod').innerHTML = getColoredValueHtml(maxHoldingPeriodMs === 0 ? 'N/A' : formatDuration(maxHoldingPeriodMs), false, 1);
            if (document.getElementById('maxTpPips')) document.getElementById('maxTpPips').innerHTML = getColoredValueHtml(maxTpPips === -Infinity ? 'N/A' : maxTpPips, false, 1);
            if (document.getElementById('maxSlPips')) document.getElementById('maxSlPips').innerHTML = getColoredValueHtml(maxSlPips === Infinity ? 'N/A' : maxSlPips, false, 1);
            console.log("Risk and reward statistics updated.");
        }

        const chartSections = {
            'overallSummaryStatisticsSection': { render: calculateSummaryStatistics, chartInstance: () => null, setInstance: () => {}, canvasId: null, loadingId: null, errorId: null, noDataId: null, hasRendered: false },
            'riskRewardStatisticsSection': { render: updateRiskRewardStatistics, chartInstance: () => null, setInstance: () => {}, canvasId: null, loadingId: null, errorId: null, noDataId: null, hasRendered: false },
            'assetSuccessStatisticsSection': { render: fetchAndRenderPieChart, chartInstance: () => assetPieChart, setInstance: (chart) => assetPieChart = chart, canvasId: 'assetSuccessPieChart', loadingId: 'pieChartLoading', errorId: 'pieChartError', noDataId: 'pieChartNoData', hasRendered: false },
             'dailyLineStatisticsSection': { render: fetchAndRenderDailyLineChart, chartInstance: () => dailyLineChart, setInstance: (chart) => dailyLineChart = chart, canvasId: 'dailyLineChart', loadingId: 'dailyLineChartLoading', errorId: 'dailyLineChartError', noDataId: 'dailyLineChartNoData', hasRendered: false },
            'monthlyBarStatisticsSection': { render: fetchAndRenderMonthlyBarChart, chartInstance: () => monthlyBarChart, setInstance: (chart) => monthlyBarChart = chart, canvasId: 'monthlyBarChart', loadingId: 'monthlyBarChartLoading', errorId: 'monthlyBarChartError', noDataId: 'monthlyBarChartNoData', hasRendered: false },
            'overallPercentageCumulativeStatisticsSection': { render: fetchAndRenderOverallPercentageCumulativeChart, chartInstance: () => overallPercentageCumulativeChart, setInstance: (chart) => overallPercentageCumulativeChart = chart, canvasId: 'overallPercentageCumulativeChart', loadingId: 'overallPercentageCumulativeChartLoading', errorId: 'overallPercentageCumulativeChartError', noDataId: 'overallPercentageCumulativeChartNoData', hasRendered: false },
            'overallBalanceCumulativeStatisticsSection': { render: fetchAndRenderOverallBalanceCumulativeChart, chartInstance: () => overallBalanceCumulativeChart, setInstance: (chart) => overallBalanceCumulativeChart = chart, canvasId: 'overallBalanceCumulativeChart', loadingId: 'overallBalanceCumulativeChartLoading', errorId: 'overallBalanceCumulativeChartError', noDataId: 'overallBalanceCumulativeChartNoData', hasRendered: false },
            'overallPipsCumulativeStatisticsSection': { render: fetchAndRenderOverallPipsCumulativeChart, chartInstance: () => overallPipsCumulativeChart, setInstance: (chart) => overallPipsCumulativeChart = chart, canvasId: 'overallPipsCumulativeChart', loadingId: 'overallPipsCumulativeChartLoading', errorId: 'overallPipsCumulativeChartError', noDataId: 'overallPipsCumulativeChartNoData', hasRendered: false },
            'tradeFrequencyStatisticsSection': { render: fetchAndRenderTradeFrequencyChart, chartInstance: () => tradeFrequencyChart, setInstance: (chart) => tradeFrequencyChart = chart, canvasId: 'tradeFrequencyChart', loadingId: 'tradeFrequencyChartLoading', errorId: 'tradeFrequencyChartError', noDataId: 'tradeFrequencyChartNoData', hasRendered: false }
        };

        // --- SCROLL ANIMATION LOGIC ---
        const animateOnScroll = () => {
            const sections = document.querySelectorAll('.scroll-animate-section');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const sectionId = entry.target.id; const chartInfo = chartSections[sectionId];
                    if (entry.isIntersecting) {
                         entry.target.classList.add('scrolled-into-view');
                        if (chartInfo && !chartInfo.hasRendered && chartInfo.canvasId) { chartInfo.render(); chartInfo.hasRendered = true; }
                    } else {
                        entry.target.classList.remove('scrolled-into-view');
                        if (chartInfo && chartInfo.chartInstance && chartInfo.chartInstance()) { chartInfo.chartInstance().destroy(); chartInfo.setInstance(null); chartInfo.hasRendered = false; }
                    }
                });
            }, { root: null, rootMargin: '0px', threshold: 0.1 });
            sections.forEach(section => observer.observe(section));
        };

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM Content Loaded. Initializing app...");
            updateDateTime(); setInterval(updateDateTime, 1000);
            
            // Always try to initialize Firebase if config is provided
            if (Object.keys(firebaseConfig).length > 0) {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                storage = getStorage(app);

                // Authenticate
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with Firebase UID:", userId);
                        // Load data after authentication
                     await loadProfilePictures(userId); // Load multiple pictures
                        await loadCalculatedPlans(userId); // Load calculated plans
                        await loadRunningPlans(userId);   // Load running plans
                        await loadExecutedPlans(userId); // This will set up real-time listener for executed
                        // loadJoinTime is now handled by calculateSummaryStatistics
                    } else {
                        try {
                            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                                console.log("Signed in with custom token.");
                            } else {
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously.");
                            }
                        } catch (error) {
                            console.error("Firebase authentication error:", error);
                        }
                    }
                });
            } else {
                console.warn("Firebase config not found. Running in standalone mode without cloud persistence.");
                // If Firebase is not configured, still allow the app to run without cloud persistence
                // The buttons will remain visible as their display style is no longer explicitly set to 'none' here.
                // However, photo upload will still be hidden as it relies on Firebase Storage.
                // addPhotoBtn.style.display = 'none'; // This button is now removed
                loadPhotosFromLocalStorage(); // Load photos from local storage
                loadDataFromLocalStorage(); // Load other data from local storage
                renderCalculatedPlans();
                renderRunningPlans();
                renderExecutedPlans();
                calculateSummaryStatistics(); // Call here to update join time from local data
                updateRiskRewardStatistics();
                checkTradeLimits();
                displayLimitNotification(limitNotificationMessage);
            }

            if (calculatedPlansData.length === 0 && runningPlansData.length === 0 && executedPlansData.length === 0) {
                console.log("No existing data found. Adding initial sample row.");
                addInputRow({ symbol: 'EUR/USD', tradeType: 'BUY', balance: 5000, riskPercent: 0.5, priceNow: 1.08600, openPrice: 1.08500, slPrice: 1.08200, tpPrice: 1.09500, note: 'Contoh Catatan Trading' });
                calculateAllRows(); saveDataToLocalStorage();
            } else {
                console.log("Existing data found. Re-rendering all plans.");
                renderCalculatedPlans();
                renderRunningPlans();
                calculateAllRows(); // Recalculate based on input rows, which will update calculatedPlansData
            }
            renderPhotoGallery(); // Initial render of the photo gallery
            animateOnScroll(); console.log("App initialization complete.");
        });

        window.exportToPdf = exportToPdf;
    </script>
</body>
</html>
            